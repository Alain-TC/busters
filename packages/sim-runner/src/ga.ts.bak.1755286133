import fs from 'fs';
import path from 'path';
import { Worker } from 'worker_threads';
import { runEpisodes } from './runEpisodes';
import { loadBotModule } from './loadBots';

// ===== Genome & simple policy =====
export type Genome = {
  radarTurn: number;
  stunRange: number;
  releaseDist: number;
};

function clamp(n: number, lo: number, hi: number) {
  return Math.max(lo, Math.min(hi, n));
}

function randn() {
  let u = 0, v = 0;
  while (u === 0) u = Math.random();
  while (v === 0) v = Math.random();
  return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
}

function sampleGenome(m: number[], s: number[]): Genome {
  const g = {
    radarTurn: Math.round(m[0] + s[0] * randn()),
    stunRange: Math.round(m[1] + s[1] * randn()),
    releaseDist: Math.round(m[2] + s[2] * randn()),
  };
  g.radarTurn   = clamp(g.radarTurn, 1, 40);
  g.stunRange   = clamp(g.stunRange, 1200, 1850);
  g.releaseDist = clamp(g.releaseDist, 800, 1600);
  return g;
}

function vecMean(vs: number[][]) {
  const n = vs.length, d = vs[0].length;
  const out = new Array(d).fill(0);
  for (const v of vs) for (let i=0;i<d;i++) out[i]+=v[i];
  for (let i=0;i<d;i++) out[i]/=n;
  return out;
}
function vecStd(vs: number[][], m: number[]) {
  const n = vs.length, d = vs[0].length;
  const out = new Array(d).fill(0);
  for (const v of vs) for (let i=0;i<d;i++) { const dlt=v[i]-m[i]; out[i]+=dlt*dlt; }
  for (let i=0;i<d;i++) out[i]=Math.sqrt(out[i]/Math.max(1,n-1));
  return out;
}

// ===== Deterministic per-episode environment sampling =====
function seededRng(a:number,b:number,c:number,d:number){
  return function sfc32(){a|=0;b|=0;c|=0;d|=0;let t=(a+b|0)+d|0;d=d+1|0;a=b^b>>>9;b=c+(c<<3)|0;c=(c<<21|c>>>11);c=c+(t|0)|0;return (t>>>0)/4294967296;}
}
function mix(n:number){ let x=2166136261>>>0; x^=n+0x9e3779b9+(x<<6)+(x>>>2); return x>>>0; }
function sampleEnv(baseSeed:number, ep:number){
  const rng = seededRng(mix(baseSeed), mix(ep), mix(baseSeed^0xA5A5), mix(ep^0x5A5A));
  const bpp = 2 + Math.floor(rng()*3);      // 2..4
  const ghosts = 8 + Math.floor(rng()*21);  // 8..28
  const endset = [3,15,40];
  const endurance = endset[Math.floor(rng()*endset.length)];
  return { bpp, ghosts, endurance };
}

// One global Hall of Fame (best of gen each generation)
const HOF: Genome[] = [];

// Bot from genome
function genomeToBot(genome: Genome) {
  return {
    meta: { name: 'EvolvedBot', version: 'ga' },
    act(ctx: any, obs: any) {
      if (obs.self.carrying !== undefined) {
        const dHome = Math.hypot(obs.self.x - ctx.myBase.x, obs.self.y - ctx.myBase.y);
        if (dHome <= genome.releaseDist) return { type: 'RELEASE' };
        return { type: 'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
      }
      const enemy = obs.enemies?.[0];
      if (enemy && enemy.range <= genome.stunRange && obs.self.stunCd <= 0) {
        return { type: 'STUN', busterId: enemy.id };
      }
      const g = obs.ghostsVisible?.[0];
      if (g) {
        if (g.range >= 900 && g.range <= 1760) return { type: 'BUST', ghostId: g.id };
        return { type: 'MOVE', x: g.x, y: g.y };
      }
      if (!obs.self.radarUsed && obs.tick >= genome.radarTurn) return { type: 'RADAR' };
      return { type: 'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
    }
  };
}

// ==== Opponent pool ====
export async function buildBaseOppPool() {
  const greedy = await loadBotModule('@busters/agents/greedy');
  const random = await loadBotModule('@busters/agents/random');
  return [
    { name: 'greedy', bot: greedy, spec: '@busters/agents/greedy' },
    { name: 'random', bot: random, spec: '@busters/agents/random' },
  ];
}

// ==== CEM opts ====
type CEMOpts = {
  gens: number;
  pop: number;
  elitePct: number;
  seedsPer: number;
  episodesPerSeed: number;
  oppPool: Array<{ name: string; bot: any; spec?: string }>;
  hofSize: number;
  seed: number;
  artifactsDir: string;
  jobs?: number;
};

// ===== Serial evaluator (with 40% HoF opponents) =====
async function evalGenomeSerial(g: Genome, opts: CEMOpts) {
  let total = 0;
  for (let si = 0; si < opts.seedsPer; si++) {
    const seed = opts.seed + si;
    const base = opts.oppPool[si % opts.oppPool.length].bot;
    // CRN env from seed
    const rEnv = (seed * 1103515245 + 12345) >>> 0;
    const bpp = 2 + (rEnv % 3);                 // 2..4
    const ghostCount = 8 + ((rEnv >>> 3) % 21); // 8..28


    let opp: any;
    const rMix = (((seed * 1103515245 + 12345) >>> 0) % 10);
    if (HOF.length && rMix < 4) {
      const hofG = HOF[seed % HOF.length];
      opp = genomeToBot(hofG);
    } else {
      opp = base;
    }

    const me  = genomeToBot(g);

    // === randomized env per EPISODE (deterministic by seed) ===
    for (let ep = 0; ep < opts.episodesPerSeed; ep++) {
      const env = sampleEnv(seed, ep);
      const res = await runEpisodes({
        seed: seed * 1000 + ep,
        episodes: 1,
        bustersPerPlayer: env.bpp,
        ghostCount: env.ghosts,
        // endurance: env.endurance, // uncomment if engine supports it
        botA: me,
        botB: opp
      });
      total += (res.scoreA - res.scoreB);
    }
  }
  return total / (opts.seedsPer * opts.episodesPerSeed);
}

// ===== Parallel evaluator (module worker via bootstrap, 40% HoF mix) =====
async function evalGenomeParallel(pop: Genome[], opts: CEMOpts) {
  const jobs = Math.max(1, Math.floor(opts.jobs || 1));
  // classic CJS bootstrap registers tsx then loads workerEval.ts
  const workerUrl = new URL('./worker-bootstrap.cjs', import.meta.url);

  type Task = { jid: number; gi: number; seed: number; opponent: any; env: Env };
  type Env = { bpp:number; ghostCount:number };
  const tasks: Task[] = [];
  let jid = 1;

  for (let gi = 0; gi < pop.length; gi++) {
    for (let si = 0; si < opts.seedsPer; si++) {
      const seed = opts.seed + si;
      const baseSpec = opts.oppPool[si % opts.oppPool.length].spec || '@busters/agents/greedy';
      const useHof = (HOF.length && ((((gi * 73856093) ^ seed) >>> 0) % 10) < 4);
      const opponent = useHof
        ? { type: 'genome', genome: HOF[seed % HOF.length] }
        : { type: 'module', spec: baseSpec };
      // env from seed (CRN)
      const rEnv = (seed * 1103515245 + 12345) >>> 0;
      const env = { bpp: 2 + (rEnv % 3), ghostCount: 8 + ((rEnv >>> 3) % 21) };
      tasks.push({ jid: jid++, gi, seed, opponent, env });
    }
  }

  const sums = new Array(pop.length).fill(0);
  const queue = tasks.slice();
  let running = 0;

  await new Promise<void>((resolve, reject) => {
    const spawn = () => {
      while (running < jobs && queue.length) {
        const t = queue.shift()!;
        running++;
        const w = new Worker(workerUrl, { type: 'classic' });
        w.on('message', (msg: any) => {
          if (!msg.ok) {
            w.terminate();
            reject(new Error('Worker error on jid=' + t.jid + ': ' + msg.error));
            return;
          }
          sums[t.gi] += msg.diff;
          w.terminate();
          running--;
          if (queue.length) spawn();
          else if (running === 0) resolve();
        });
        w.on('error', (e) => { w.terminate(); reject(e); });
        w.postMessage({
          id: t.jid,
          genome: pop[t.gi],
          seed: t.seed,
          episodes: opts.episodesPerSeed,
          opponent: t.opponent,
          env: t.env
        });
      }
    };
    spawn();
  });

  return sums.map(s => s / opts.seedsPer);
}

// ===== CEM trainer =====
export async function trainCEM(opts: CEMOpts) {
  // defaults if CLI didnâ€™t set them
  const elitePct = opts.elitePct ?? 0.2;
  const artDir = path.resolve(process.cwd(), opts.artifactsDir);
  fs.mkdirSync(artDir, { recursive: true });

  // reset HoF for this run
  HOF.length = 0;

  let m = [15, 1700, 1500];
  let s = [6, 120, 120];
  let bestEverFit = -Infinity;
  let bestEver: Genome | null = null;

  for (let gen = 0; gen < opts.gens; gen++) {
    const pop: Genome[] = Array.from({ length: opts.pop }, () => sampleGenome(m, s));
    const jobs = Math.max(1, Math.floor(opts.jobs || 1));
    const fits = jobs <= 1
      ? await (async () => { const arr:number[] = []; for (let i=0;i<pop.length;i++) arr.push(await evalGenomeSerial(pop[i], opts)); return arr; })()
      : await evalGenomeParallel(pop, opts);

    const idx = Array.from(pop.keys()).sort((a,b) => fits[b] - fits[a]);
    const bestIdx = idx[0];
    const genBest = pop[bestIdx];
    const genBestFit = fits[bestIdx];

    fs.writeFileSync(path.join(artDir, 'last_gen_best_genome.json'), JSON.stringify(genBest, null, 2));

    if (genBestFit > bestEverFit || !bestEver) {
      bestEverFit = genBestFit;
      bestEver = genBest;
      fs.writeFileSync(path.join(artDir, 'simrunner_best_genome.json'), JSON.stringify(bestEver, null, 2));
    }

    // Hall of fame maintenance
    HOF.push(genBest);
    while (HOF.length > opts.hofSize) HOF.shift();

    // Refit from elites
    const elitesCount = Math.max(1, Math.round(opts.pop * elitePct));
    const eliteVecs = idx.slice(0, elitesCount).map(i => {
      const g = pop[i]; return [g.radarTurn, g.stunRange, g.releaseDist];
    });
    const mNew = vecMean(eliteVecs);
    const sNew = vecStd(eliteVecs, mNew);

    const alpha = 0.7;
    m = m.map((mv, i) => alpha * mNew[i] + (1 - alpha) * mv);
    s = s.map((sv, i) => clamp(alpha * sNew[i] + (1 - alpha) * sv, 1, 200));

    
    // --- metrics: mean fitness + CSV ---
    const meanFit = fits.reduce((a,b)=>a+b,0)/Math.max(1,fits.length);
    const csvPath = path.join(artDir, 'metrics.csv');
    if (!fs.existsSync(csvPath)) {
      fs.writeFileSync(csvPath, 'gen,best,mean,m0,m1,m2,s0,s1,s2,hof\n');
    }
    fs.appendFileSync(
      csvPath,
      [
        gen,
        genBestFit.toFixed(4),
        meanFit.toFixed(4),
        ...m.map(v=>Math.round(v)),
        ...s.map(v=>Math.round(v)),
        HOF.length
      ].join(',') + '\n'
    );

    console.log(`CEM gen ${gen}: best=${genBestFit.toFixed(2)} m=[${m.map(x=>Math.round(x)).join(',')}] (jobs=${jobs}) env=CRN(bpp 2-4, ghosts 8-28)`);
  
  }

  // convenience: write a workspace bot from the best genome
  if (bestEver) {
    const outBot = path.resolve(process.cwd(), '../../agents/evolved-bot.js');
    try { compileGenomeToJS(path.join(artDir, 'simrunner_best_genome.json'), outBot); } catch {}
  }

  return { best: bestEver!, fitness: bestEverFit };
}

// ===== Exporter (writes single-file JS bot) =====
export function compileGenomeToJS(inPath: string, outPath: string) {
  const absIn = path.resolve(process.cwd(), inPath);
  if (!fs.existsSync(absIn)) throw new Error(`Genome JSON not found: ${absIn}`);
  const g = JSON.parse(fs.readFileSync(absIn, 'utf-8')) as Genome;

  const lines = [
    "/** Auto-generated single-file bot from genome */",
    "export const meta = { name: \"EvolvedBot\", version: \"ga\" };",
    "export function act(ctx, obs) {",
    "  if (obs.self.carrying !== undefined) {",
    "    const d = Math.hypot(obs.self.x - ctx.myBase.x, obs.self.y - ctx.myBase.y);",
    `    if (d <= ${g.releaseDist}) return { type: "RELEASE" };`,
    "    return { type: \"MOVE\", x: ctx.myBase.x, y: ctx.myBase.y };",
    "  }",
    `  const enemy = obs.enemies?.[0];`,
    `  if (enemy && enemy.range <= ${g.stunRange} && obs.self.stunCd <= 0) return { type: "STUN", busterId: enemy.id };`,
    "  const ghost = obs.ghostsVisible?.[0];",
    "  if (ghost) {",
    "    if (ghost.range >= 900 && ghost.range <= 1760) return { type: \"BUST\", ghostId: ghost.id };",
    "    return { type: \"MOVE\", x: ghost.x, y: ghost.y };",
    "  }",
    `  if (!obs.self.radarUsed && obs.tick >= ${g.radarTurn}) return { type: "RADAR" };`,
    "  return { type: \"MOVE\", x: ctx.myBase.x, y: ctx.myBase.y };",
    "}"
  ];
  const code = lines.join('\n');

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive: true });
  fs.writeFileSync(absOut, code);
  console.log('Wrote single-file bot -> ' + absOut);
}

