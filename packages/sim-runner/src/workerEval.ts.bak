import { parentPort } from 'worker_threads';
import { runEpisodes } from './runEpisodes';
import { loadBotModule } from './loadBots';

type Genome = { radarTurn:number; stunRange:number; releaseDist:number; };

function genomeToBot(g: Genome) {
  return {
    meta: { name: 'HOFGenome', version: 'ga' },
    act(ctx: any, obs: any) {
      if (obs.self.carrying !== undefined) {
        const d = Math.hypot(obs.self.x - ctx.myBase.x, obs.self.y - ctx.myBase.y);
        if (d <= g.releaseDist) return { type: 'RELEASE' };
        return { type: 'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
      }
      const e = obs.enemies?.[0];
      if (e && e.range <= g.stunRange && obs.self.stunCd <= 0) return { type: 'STUN', busterId: e.id };
      const ghost = obs.ghostsVisible?.[0];
      if (ghost) {
        if (ghost.range >= 900 && ghost.range <= 1760) return { type: 'BUST', ghostId: ghost.id };
        return { type: 'MOVE', x: ghost.x, y: ghost.y };
      }
      if (!obs.self.radarUsed && obs.tick >= g.radarTurn) return { type: 'RADAR' };
      return { type: 'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
    }
  };
}

parentPort!.on('message', async (msg: any) => {
  try {
    const me = genomeToBot(msg.genome as Genome);

    let opp: any;
    const op = msg.opponent;
    if (typeof op === 'string') opp = await loadBotModule(op);
    else if (op?.type === 'module') opp = await loadBotModule(op.spec);
    else if (op?.type === 'genome') opp = genomeToBot(op.genome as Genome);
    else throw new Error('Invalid opponent descriptor');

    const res = await runEpisodes({
      seed: msg.seed,
      episodes: msg.episodes,
      bustersPerPlayer: 3,
      ghostCount: 12,
      botA: me,
      botB: opp
    });

    parentPort!.postMessage({ ok: true, id: msg.id, diff: res.scoreA - res.scoreB });
  } catch (err: any) {
    parentPort!.postMessage({ ok: false, id: msg?.id, error: String(err?.stack || err) });
  }
});
