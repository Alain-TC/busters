import fs from 'fs';
import path from 'path';
import { Worker } from 'worker_threads';
import { runEpisodes } from './runEpisodes';
import { loadBotModule } from './loadBots';
import {
  loadElo, saveElo, pickOpponentPFSP, ensureOpponentId, recordMatch,
  PFSPCandidate
} from './elo';
import { logPFSPPick, logPFSPResult, resetPFSPLog } from './pfsp_log';

// ===== Genome & simple policy =====
export type Genome = { radarTurn:number; stunRange:number; releaseDist:number; };

function clamp(n:number, lo:number, hi:number){ return Math.max(lo, Math.min(hi, n)); }
function randn(){ let u=0,v=0; while(u===0)u=Math.random(); while(v===0)v=Math.random(); return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

function sampleGenome(m:number[], s:number[]):Genome{
  const g = { radarTurn: Math.round(m[0]+s[0]*randn()), stunRange: Math.round(m[1]+s[1]*randn()), releaseDist: Math.round(m[2]+s[2]*randn()) };
  g.radarTurn   = clamp(g.radarTurn,1,40);
  g.stunRange   = clamp(g.stunRange,1200,1850);
  g.releaseDist = clamp(g.releaseDist,800,1600);
  return g;
}

function vecMean(vs:number[][]){ const n=vs.length,d=vs[0].length,out=new Array(d).fill(0); for(const v of vs){ for(let i=0;i<d;i++) out[i]+=v[i]; } for(let i=0;i<d;i++) out[i]/=n; return out; }
function vecStd(vs:number[][],m:number[]){ const n=vs.length,d=vs[0].length,out=new Array(d).fill(0); for(const v of vs){ for(let i=0;i<d;i++){ const dd=v[i]-m[i]; out[i]+=dd*dd; } } for(let i=0;i<d;i++) out[i]=Math.sqrt(out[i]/Math.max(1,n-1)); return out; }

// HoF per run
const HOF: Genome[] = [];

// Bot from genome
function genomeToBot(genome:Genome){
  return {
    meta: { name: 'EvolvedBot', version: 'ga' },
    act(ctx:any, obs:any){
      if (obs.self.carrying !== undefined){
        const dHome = Math.hypot(obs.self.x - ctx.myBase.x, obs.self.y - ctx.myBase.y);
        if (dHome <= genome.releaseDist) return { type:'RELEASE' };
        return { type:'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
      }
      const enemy = obs.enemies?.[0];
      if (enemy && enemy.range <= genome.stunRange && obs.self.stunCd <= 0) return { type:'STUN', busterId: enemy.id };
      const g = obs.ghostsVisible?.[0];
      if (g){
        if (g.range >= 900 && g.range <= 1760) return { type:'BUST', ghostId: g.id };
        return { type:'MOVE', x: g.x, y: g.y };
      }
      if (!obs.self.radarUsed && obs.tick >= genome.radarTurn) return { type:'RADAR' };
      return { type:'MOVE', x: ctx.myBase.x, y: ctx.myBase.y };
    }
  };
}

// Base opponent pool
export async function buildBaseOppPool(){
  const greedy  = await loadBotModule('@busters/agents/greedy');
  const random  = await loadBotModule('@busters/agents/random');
  const camper  = await loadBotModule('@busters/agents/camper');
  const stunner = await loadBotModule('@busters/agents/stunner');
  return [
    { name:'greedy',  bot:greedy,  spec:'@busters/agents/greedy'  },
    { name:'random',  bot:random,  spec:'@busters/agents/random'  },
    { name:'camper',  bot:camper,  spec:'@busters/agents/camper'  },
    { name:'stunner', bot:stunner, spec:'@busters/agents/stunner' }
  ];
}

// CEM opts
type CEMOpts = {
  gens:number; pop:number; elitePct:number; seedsPer:number; episodesPerSeed:number;
  oppPool:Array<{ name:string; bot:any; spec?:string }>;
  hofSize:number; seed:number; artifactsDir:string; jobs?:number;
};

// Env from seed (CRN)
function envFromSeed(s:number){ let r=(s*1103515245+12345)>>>0; const bpp=2+(r%3); r=(r*1103515245+12345)>>>0; const ghosts=8+(r%21); return { bpp, ghosts }; }

function ensureCands(oppPool:CEMOpts['oppPool'], elo:Record<string,number>): PFSPCandidate[] {
  const cands:PFSPCandidate[]=[];
  for (const o of oppPool){
    const id=o.spec!;
    cands.push({ type:'module', spec:id, id });
    ensureOpponentId(elo,id,1000);
  }
  for (let i=0;i<HOF.length;i++){
    const tag=`hof:${HOF[i].radarTurn},${HOF[i].stunRange},${HOF[i].releaseDist}`;
    cands.push({ type:'genome', tag, genome:HOF[i], id:tag });
    ensureOpponentId(elo,tag,1000);
  }
  if (cands.length===0){
    const id=oppPool[0].spec!; cands.push({ type:'module', spec:id, id }); ensureOpponentId(elo,id,1000);
  }
  return cands;
}

// SAFE: prefer id/tag; if missing, derive from genome; never return unknown unless nothing is available
function toOppIdAndSummary(picked: PFSPCandidate){
  if ((picked as any).type === 'module') {
    const spec = (picked as any).spec as string;
    const id = (picked as any).id ?? spec;
    return { oppId:id, oppSummary: { type:'module' as const, id, spec } };
  } else {
    // try existing id/tag first
    let id = (picked as any).id ?? (picked as any).tag;
    // derive from genome if needed
    if (!id) {
      const g = (picked as any).genome as Partial<Genome> | undefined;
      if (g && typeof g.radarTurn === 'number' && typeof g.stunRange === 'number' && typeof g.releaseDist === 'number') {
        id = `hof:${g.radarTurn},${g.stunRange},${g.releaseDist}`;
      }
    }
    if (!id) id = 'hof:unknown';
    return { oppId:id, oppSummary: { type:'genome' as const, tag:id } };
  }
}

// ---- Serial eval ----
async function evalGenomeSerial(g:Genome, opts:CEMOpts, elo:Record<string,number>){
  let total=0;
  const cands = ensureCands(opts.oppPool, elo);

  for (let si=0; si<opts.seedsPer; si++){
    const baseSeed = opts.seed + si;
    const { bpp, ghosts } = envFromSeed(baseSeed);

    const picked = pickOpponentPFSP(elo, cands);
    const { oppId, oppSummary } = toOppIdAndSummary(picked);
    logPFSPPick({ ts:new Date().toISOString(), phase:'serial', seed:baseSeed, oppId, opp:oppSummary });

    const opp = (picked.type==='module')
      ? opts.oppPool.find(o=>o.spec===(picked as any).spec)!.bot
      : genomeToBot((picked as any).genome as Genome);

    const me = genomeToBot(g);
    const res = await runEpisodes({ seed:baseSeed, episodes:opts.episodesPerSeed, bustersPerPlayer:bpp, ghostCount:ghosts, botA:me, botB:opp });

    const diff = res.scoreA - res.scoreB;
    total += diff;

    logPFSPResult({ ts:new Date().toISOString(), phase:'serial', oppId, opp:oppSummary, diff });
    recordMatch(elo, oppId, diff > 0);
  }
  return total/opts.seedsPer;
}

// ---- Parallel eval ----
async function evalGenomeParallel(pop:Genome[], opts:CEMOpts, elo:Record<string,number>){
  const jobs = Math.max(1, Math.floor(opts.jobs||1));
  const workerUrl = new URL('./worker-bootstrap.cjs', import.meta.url);

  type Task = {
    jid:number; gi:number; seed:number; opponent:any; role:'A'|'B';
    bpp:number; ghosts:number; oppId:string;
    oppSummary:{type:'module'|'genome'; id?:string; spec?:string; tag?:string};
  };
  const tasks:Task[] = [];
  let jid=1;

  const cands = ensureCands(opts.oppPool, elo);

  for (let gi=0; gi<pop.length; gi++){
    for (let si=0; si<opts.seedsPer; si++){
      const baseSeed = opts.seed + si;
      const { bpp, ghosts } = envFromSeed(baseSeed);

      const picked = pickOpponentPFSP(elo, cands);

      // Build the concrete opponent that we will actually run
      const opponent = (picked.type === 'module')
        ? { type: 'module', spec: (picked as any).spec }
        : { type: 'genome', genome: (picked as any).genome, tag: (picked as any).tag };

      // Derive a stable oppId from the concrete opponent (prefer genome → tag → picker ids)
      const oppId =
        picked.type === 'module'
          ? ((picked as any).id ?? (picked as any).spec ?? (opponent as any).spec ?? '@busters/agents/unknown')
          : (() => {
              const g = (opponent as any).genome;
              if (g && typeof g.radarTurn === 'number' && typeof g.stunRange === 'number' && typeof g.releaseDist === 'number') {
                return `hof:${g.radarTurn},${g.stunRange},${g.releaseDist}`;
              }
              return (picked as any).id ?? (picked as any).tag ?? 'hof:unknown';
            })();

      // Keep log payload small but informative
      const oppSummary = picked.type === 'module'
        ? { type: 'module' as const, id: oppId, spec: (picked as any).spec }
        : { type: 'genome' as const, tag: oppId };

      // Log the pick with the derived ID
      logPFSPPick({ ts: new Date().toISOString(), phase: 'parallel', gi, seed: baseSeed, oppId, opp: oppSummary });


      const seedA = (baseSeed*2)>>>0;
      const seedB = (baseSeed*2+1)>>>0;

      tasks.push({ jid:jid++, gi, seed:seedA, opponent, role:'A', bpp, ghosts, oppId, oppSummary });
      tasks.push({ jid:jid++, gi, seed:seedB, opponent, role:'B', bpp, ghosts, oppId, oppSummary });
    }
  }

  const sums = new Array(pop.length).fill(0);
  const queue = tasks.slice();
  let running=0;

  await new Promise<void>((resolve,reject)=>{
    const spawn=()=>{
      while (running<jobs && queue.length){
        const t = queue.shift()!;
        running++;
        const w = new Worker(workerUrl, { type:'classic' });

        w.on('message', (msg:any)=>{
          if (!msg.ok){ w.terminate(); reject(new Error('Worker error on jid='+t.jid+': '+msg.error)); return; }
          sums[t.gi] += msg.diff;

          logPFSPResult({ ts:new Date().toISOString(), phase:'parallel', gi:t.gi, jid:t.jid, oppId:t.oppId, opp:t.oppSummary, diff:msg.diff });

          // Elo update: treat ties as random half-win to avoid Elo drift
          const didWin = msg.diff > 0 ? true : (msg.diff < 0 ? false : Math.random() < 0.5);
          recordMatch(elo, t.oppId, didWin);

          w.terminate(); running--;
          if (queue.length) spawn(); else if (running===0) resolve();
        });
        w.on('error', (e)=>{ w.terminate(); reject(e); });

        w.postMessage({ id:t.jid, genome:pop[t.gi], seed:t.seed, episodes:opts.episodesPerSeed, opponent:t.opponent, bpp:t.bpp, ghosts:t.ghosts, role:t.role });
      }
    };
    spawn();
  });

  return sums.map(s => s/(opts.seedsPer*2));
}

// ---- Trainer ----
export async function trainCEM(opts:CEMOpts){
  try { resetPFSPLog(); } catch {}
  const elitePct = opts.elitePct ?? 0.2;
  const artDir = path.resolve(process.cwd(), opts.artifactsDir);
  fs.mkdirSync(artDir, { recursive:true });

  HOF.length = 0;
  const elo = loadElo(artDir);

  let m=[15,1700,1500], s=[6,120,120];
  let bestEver:Genome|null = null;
  let bestEverFit=-Infinity;

  const ema:(number|null)[] = [];
  const emaAlpha=0.6;

  for (let gen=0; gen<opts.gens; gen++){
    const pop:Genome[] = Array.from({length:opts.pop}, ()=>sampleGenome(m,s));
    if (ema.length!==pop.length){ for(let i=ema.length;i<pop.length;i++) ema.push(null); }

    const jobs = Math.max(1, Math.floor(opts.jobs||1));
    const fits = jobs<=1
      ? await (async()=>{ const arr:number[]=[]; for(let i=0;i<pop.length;i++) arr.push(await evalGenomeSerial(pop[i],opts,elo)); return arr; })()
      : await evalGenomeParallel(pop, opts, elo);

    const smoothed = fits.map((f,i)=>{ const prev=ema[i]; const v=(prev===null)?f:(emaAlpha*f + (1-emaAlpha)*prev); ema[i]=v; return v; });

    const idx = Array.from(pop.keys()).sort((a,b)=>smoothed[b]-smoothed[a]);
    const bestIdx = idx[0];
    const genBest = pop[bestIdx];
    const genBestFit = fits[bestIdx];
    const genBestEMA = smoothed[bestIdx];

    fs.writeFileSync(path.join(artDir,'last_gen_best_genome.json'), JSON.stringify(genBest,null,2));
    if (genBestFit>bestEverFit || !bestEver){ bestEverFit=genBestFit; bestEver=genBest; fs.writeFileSync(path.join(artDir,'simrunner_best_genome.json'), JSON.stringify(bestEver,null,2)); }

    HOF.push(genBest); while (HOF.length>opts.hofSize) HOF.shift();

    const elitesCount = Math.max(1, Math.round(opts.pop*elitePct));
    const eliteVecs = idx.slice(0,elitesCount).map(i=>{ const g=pop[i]; return [g.radarTurn,g.stunRange,g.releaseDist]; });
    const mNew = vecMean(eliteVecs);
    const sNew = vecStd(eliteVecs, mNew);

    const alpha=0.7;
    m = m.map((mv,i)=> alpha*mNew[i] + (1-alpha)*mv);
    s = s.map((sv,i)=> clamp(alpha*sNew[i] + (1-alpha)*sv, 1, 200));

    console.log(
      'CEM gen '+gen+
      ': bestRaw='+genBestFit.toFixed(2)+
      ' bestEMA='+genBestEMA.toFixed(2)+
      ' m=['+m.map(x=>Math.round(x)).join(',')+']'+
      ' (jobs='+jobs+') env=CRN(bpp 2-4, ghosts 8-28)'
    );
  }

  if (bestEver){
    const outBot = path.resolve(process.cwd(), '../../agents/evolved-bot.js');
    try { compileGenomeToJS(path.join(artDir,'simrunner_best_genome.json'), outBot); } catch {}
  }

  saveElo(artDir, elo);
  return { best: bestEver!, fitness: bestEverFit };
}

// ---- Exporter ----
export function compileGenomeToJS(inPath:string, outPath:string){
  const absIn = path.resolve(process.cwd(), inPath);
  if (!fs.existsSync(absIn)) throw new Error('Genome JSON not found: '+absIn);
  const g = JSON.parse(fs.readFileSync(absIn,'utf-8')) as Genome;

  const lines:string[] = [];
  lines.push('/** Auto-generated single-file bot from genome */');
  lines.push('export const meta = { name: "EvolvedBot", version: "ga" };');
  lines.push('export function act(ctx, obs) {');
  lines.push('  if (obs.self.carrying !== undefined) {');
  lines.push('    const d = Math.hypot(obs.self.x - ctx.myBase.x, obs.self.y - ctx.myBase.y);');
  lines.push('    if (d <= ' + g.releaseDist + ') return { type: "RELEASE" };');
  lines.push('    return { type: "MOVE", x: ctx.myBase.x, y: ctx.myBase.y };');
  lines.push('  }');
  lines.push('  const enemy = obs.enemies?.[0];');
  lines.push('  if (enemy && enemy.range <= ' + g.stunRange + ' && obs.self.stunCd <= 0) return { type: "STUN", busterId: enemy.id };');
  lines.push('  const ghost = obs.ghostsVisible?.[0];');
  lines.push('  if (ghost) {');
  lines.push('    if (ghost.range >= 900 && ghost.range <= 1760) return { type: "BUST", ghostId: ghost.id };');
  lines.push('    return { type: "MOVE", x: ghost.x, y: ghost.y };');
  lines.push('  }');
  lines.push('  if (!obs.self.radarUsed && obs.tick >= ' + g.radarTurn + ') return { type: "RADAR" };');
  lines.push('  return { type: "MOVE", x: ctx.myBase.x, y: ctx.myBase.y };');
  lines.push('}');
  const code = lines.join('\n');

  const absOut = path.resolve(process.cwd(), outPath);
  fs.mkdirSync(path.dirname(absOut), { recursive:true });
  fs.writeFileSync(absOut, code);
  console.log('Wrote single-file bot -> ' + absOut);
}
