/**
 * CodinGame Busters — hybrid bot
 * Generated by scripts/export-codingame.ts
 * Version 2bd9bb7 — exported 2025-08-22T13:38:16.680Z
 */

var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // hybrid-params.ts
  var TUNE = {
  "RELEASE_DIST": 1600,
  "STUN_RANGE": 1834,
  "RADAR1_TURN": 2,
  "RADAR2_TURN": 55,
  "SPACING": 954,
  "SPACING_PUSH": 289,
  "BLOCK_RING": 1670,
  "DEFEND_RADIUS": 3341,
  "EXPLORE_STEP_REWARD": 0.9676032069672904
};
  var WEIGHTS = {
  "BUST_BASE": 12,
  "BUST_RING_BONUS": 7,
  "BUST_ENEMY_NEAR_PEN": 6,
  "INTERCEPT_BASE": 16,
  "INTERCEPT_DIST_PEN": 0.006268810020792386,
  "DEFEND_BASE": 10,
  "DEFEND_NEAR_BONUS": 4,
  "BLOCK_BASE": 5,
  "EXPLORE_BASE": 3,
  "DIST_PEN": 0.0024519620026867764
};

  // fog.ts
  var W = 16e3;
  var H = 9e3;
  var CELL = 400;
  var GX = Math.ceil(W / CELL);
  var GY = Math.ceil(H / CELL);
  function clamp(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v));
  }
  function dist(ax, ay, bx, by) {
    return Math.hypot(ax - bx, ay - by);
  }
  var Fog = class {
    constructor(spawnPoints = [], ghostDecay = 0.97, corridorDecay = 0.9) {
      __publicField(this, "tick", 0);
      // last visited tick, -1 means never
      __publicField(this, "last");
      // belief heat (0..+inf, small decay)
      __publicField(this, "heat");
      // corridor probability for unseen carriers
      __publicField(this, "corridor");
      __publicField(this, "ghostDecay");
      __publicField(this, "corridorDecay");
      __publicField(this, "spawns");
      this.last = new Int32Array(GX * GY);
      this.heat = new Float32Array(GX * GY);
      this.corridor = new Float32Array(GX * GY);
      this.ghostDecay = ghostDecay;
      this.corridorDecay = corridorDecay;
      this.spawns = spawnPoints.slice();
      for (let i = 0; i < this.last.length; i++) this.last[i] = -1;
      this.seedSpawns();
    }
    reset() {
      this.tick = 0;
      this.last.fill(-1);
      this.heat.fill(0);
      this.corridor.fill(0);
      this.seedSpawns();
    }
    beginTick(t) {
      if (t === this.tick) return;
      this.tick = t;
      for (let i = 0; i < this.heat.length; i++) {
        this.heat[i] *= this.ghostDecay;
        if (this.heat[i] < 0.02) this.heat[i] = 0;
        this.corridor[i] *= this.corridorDecay;
        if (this.corridor[i] < 0.02) this.corridor[i] = 0;
      }
      this.diffuse();
      this.normalize();
    }
    idxOf(x, y) {
      const gx = clamp(Math.floor(x / CELL), 0, GX - 1);
      const gy = clamp(Math.floor(y / CELL), 0, GY - 1);
      return gy * GX + gx;
    }
    markVisited(p) {
      const i = this.idxOf(p.x, p.y);
      this.last[i] = this.tick;
      this.heat[i] *= 0.5;
      this.corridor[i] *= 0.5;
      this.normalize();
      this.normalizeCorridor();
    }
    /** Clear vision circle (approx) by setting heat low & refresh visited in the disk */
    clearCircle(p, r) {
      const gx0 = clamp(Math.floor((p.x - r) / CELL), 0, GX - 1);
      const gx1 = clamp(Math.floor((p.x + r) / CELL), 0, GX - 1);
      const gy0 = clamp(Math.floor((p.y - r) / CELL), 0, GY - 1);
      const gy1 = clamp(Math.floor((p.y + r) / CELL), 0, GY - 1);
      const r2 = r * r;
      for (let gy = gy0; gy <= gy1; gy++) {
        for (let gx = gx0; gx <= gx1; gx++) {
          const cx = gx * CELL + CELL / 2;
          const cy = gy * CELL + CELL / 2;
          if ((cx - p.x) * (cx - p.x) + (cy - p.y) * (cy - p.y) <= r2) {
            const i = gy * GX + gx;
            this.last[i] = this.tick;
            this.heat[i] *= 0.2;
            this.corridor[i] *= 0.2;
          }
        }
      }
      this.normalize();
      this.normalizeCorridor();
    }
    /** Probability/heat at a given point */
    probAt(p) {
      const i = this.idxOf(p.x, p.y);
      return this.heat[i];
    }
    /** Positive evidence: increase belief near a ghost sighting */
    bumpGhost(x, y) {
      const gx0 = clamp(Math.floor((x - 800) / CELL), 0, GX - 1);
      const gx1 = clamp(Math.floor((x + 800) / CELL), 0, GX - 1);
      const gy0 = clamp(Math.floor((y - 800) / CELL), 0, GY - 1);
      const gy1 = clamp(Math.floor((y + 800) / CELL), 0, GY - 1);
      for (let gy = gy0; gy <= gy1; gy++) {
        for (let gx = gx0; gx <= gx1; gx++) {
          const cx = gx * CELL + CELL / 2;
          const cy = gy * CELL + CELL / 2;
          const d2 = dist(cx, cy, x, y);
          const w = Math.max(0, 1 - d2 / 900);
          const i = gy * GX + gx;
          this.heat[i] += 0.8 * w;
        }
      }
      this.normalize();
    }
    /** Track corridor probability along a path of points (unseen carrier) */
    bumpCorridor(path) {
      for (const p of path) {
        const i = this.idxOf(p.x, p.y);
        this.corridor[i] += 1;
      }
      this.normalizeCorridor();
    }
    diffuse() {
      const next = new Float32Array(this.heat.length);
      for (let gy = 0; gy < GY; gy++) {
        for (let gx = 0; gx < GX; gx++) {
          const i = gy * GX + gx;
          const v = this.heat[i];
          const share = v / 5;
          next[i] += share;
          const nbs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1]
          ];
          for (const [dx, dy] of nbs) {
            const nx = gx + dx, ny = gy + dy;
            if (nx >= 0 && nx < GX && ny >= 0 && ny < GY) {
              next[ny * GX + nx] += share;
            } else {
              next[i] += share;
            }
          }
        }
      }
      this.heat = next;
    }
    normalize() {
      let sum = 0;
      for (const v of this.heat) sum += v;
      if (sum <= 0) return;
      for (let i = 0; i < this.heat.length; i++) this.heat[i] /= sum;
    }
    normalizeCorridor() {
      let sum = 0;
      for (const v of this.corridor) sum += v;
      if (sum <= 0) return;
      for (let i = 0; i < this.corridor.length; i++) this.corridor[i] /= sum;
    }
    /** Seed initial ghost belief at spawn points */
    seedSpawns() {
      if (!this.spawns.length) return;
      for (const s of this.spawns) {
        const i = this.idxOf(s.x, s.y);
        this.heat[i] += 1;
      }
      this.normalize();
    }
    /** Frontier score and target based on age * distance * heat */
    frontier(from) {
      let bestI = 0;
      let bestS = -1;
      for (let gy = 0; gy < GY; gy++) {
        for (let gx = 0; gx < GX; gx++) {
          const i = gy * GX + gx;
          const cx = gx * CELL + CELL / 2;
          const cy = gy * CELL + CELL / 2;
          const lv = this.last[i];
          const age = lv < 0 ? 200 : this.tick - lv;
          const d2 = dist(from.x, from.y, cx, cy);
          const score = age * d2 * (this.heat[i] + 1);
          if (score > bestS) {
            bestS = score;
            bestI = i;
          }
        }
      }
      const bx = bestI % GX * CELL + CELL / 2;
      const by = Math.floor(bestI / GX) * CELL + CELL / 2;
      return { target: { x: clamp(bx, 0, W), y: clamp(by, 0, H) }, score: bestS };
    }
    /** Return frontier target only */
    pickFrontierTarget(from) {
      return this.frontier(from).target;
    }
  };

  // ../shared/src/constants.ts
  var RULES = {
    VISION: 2200,
    RADAR_VISION: 4400,
    MOVE_SPEED: 800,
    BUST_MIN: 900,
    BUST_MAX: 1760,
    STUN_RANGE: 1760,
    STUN_DURATION: 10,
    STUN_COOLDOWN: 20,
    GHOST_FLEE: 400,
    BASE_RADIUS: 1600,
    EJECT_MAX: 1760
  };

  // lib/state.ts
  var MAP_W = 16e3;
  var MAP_H = 9e3;
  var DEFAULT_ENEMY_MAX_AGE = 40;
  function clamp2(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v));
  }
  function centerOfCell(cx, cy, cellW, cellH) {
    return { x: cx * cellW + cellW / 2, y: cy * cellH + cellH / 2 };
  }
  var HybridState = class {
    constructor(bounds, cols = 8, rows = 5, enemyMaxAge = DEFAULT_ENEMY_MAX_AGE, spawnPoints = [], ghostDecay = 0.95, corridorDecay = 0.9) {
      // Coarse grid (defaults 8x5) for coverage; counts visits
      __publicField(this, "cols");
      __publicField(this, "rows");
      __publicField(this, "visits");
      __publicField(this, "cellW");
      __publicField(this, "cellH");
      // Ghost probability heatmap per cell
      __publicField(this, "ghostProb");
      __publicField(this, "ghostDecay");
      // corridor probability for unseen carriers
      __publicField(this, "corridorProb");
      __publicField(this, "corridorDecay");
      // Enemy last-seen
      __publicField(this, "enemies", /* @__PURE__ */ new Map());
      __publicField(this, "enemyMaxAge");
      // Per-buster role tracking
      __publicField(this, "roles", /* @__PURE__ */ new Map());
      var _a, _b;
      const W4 = (_a = bounds == null ? void 0 : bounds.w) != null ? _a : MAP_W;
      const H4 = (_b = bounds == null ? void 0 : bounds.h) != null ? _b : MAP_H;
      this.cols = cols;
      this.rows = rows;
      this.cellW = W4 / cols;
      this.cellH = H4 / rows;
      const size = cols * rows;
      this.visits = Array(size).fill(0);
      this.enemyMaxAge = enemyMaxAge;
      this.ghostProb = Array(size).fill(0);
      this.corridorProb = Array(size).fill(0);
      this.ghostDecay = ghostDecay;
      this.corridorDecay = corridorDecay;
      this.seedGhosts(spawnPoints);
    }
    idxFromPoint(p) {
      const cx = clamp2(Math.floor(p.x / this.cellW), 0, this.cols - 1);
      const cy = clamp2(Math.floor(p.y / this.cellH), 0, this.rows - 1);
      return cy * this.cols + cx;
    }
    touchVisit(p) {
      this.visits[this.idxFromPoint(p)]++;
    }
    /** Seed ghost probabilities around known spawn points */
    seedGhosts(spawns) {
      for (const s of spawns) {
        const i = this.idxFromPoint(s);
        this.ghostProb[i] = 1;
      }
      this.normalizeGhosts();
    }
    /** Apply exponential decay to all ghost probabilities */
    decayGhosts() {
      for (let i = 0; i < this.ghostProb.length; i++) {
        this.ghostProb[i] *= this.ghostDecay;
      }
      this.normalizeGhosts();
    }
    /** Decay corridor probabilities for unseen carriers */
    decayCorridors() {
      for (let i = 0; i < this.corridorProb.length; i++) {
        this.corridorProb[i] *= this.corridorDecay;
      }
    }
    /** Update probabilities with observed or captured ghosts */
    updateGhosts(visible = [], captured = []) {
      for (const g of visible) {
        const i = this.idxFromPoint(g);
        this.ghostProb[i] = 1;
      }
      for (const g of captured) {
        const i = this.idxFromPoint(g);
        this.ghostProb[i] = 0;
      }
      this.normalizeGhosts();
    }
    /** Increase corridor probabilities based on unseen carrier paths */
    updateCorridors(base) {
      for (const e of this.enemies.values()) {
        if (!e.carrying) continue;
        const path = predictEnemyPath(e, base, 10);
        for (const p of path) {
          const i = this.idxFromPoint(p);
          this.corridorProb[i] += 1;
        }
      }
      this.normalizeCorridors();
    }
    /** Diffuse probabilities to neighboring cells */
    diffuseGhosts() {
      const next = new Array(this.ghostProb.length).fill(0);
      for (let cy = 0; cy < this.rows; cy++) {
        for (let cx = 0; cx < this.cols; cx++) {
          const i = cy * this.cols + cx;
          const v = this.ghostProb[i];
          const share = v / 5;
          next[i] += share;
          const nbs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1]
          ];
          for (const [dx, dy] of nbs) {
            const nx = cx + dx, ny = cy + dy;
            if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
              next[ny * this.cols + nx] += share;
            } else {
              next[i] += share;
            }
          }
        }
      }
      for (let i = 0; i < this.ghostProb.length; i++) this.ghostProb[i] = next[i];
      this.normalizeGhosts();
    }
    /** Reduce probability mass in a vision circle */
    subtractSeen(p, r) {
      const x0 = clamp2(Math.floor((p.x - r) / this.cellW), 0, this.cols - 1);
      const x1 = clamp2(Math.floor((p.x + r) / this.cellW), 0, this.cols - 1);
      const y0 = clamp2(Math.floor((p.y - r) / this.cellH), 0, this.rows - 1);
      const y1 = clamp2(Math.floor((p.y + r) / this.cellH), 0, this.rows - 1);
      const r2 = r * r;
      for (let cy = y0; cy <= y1; cy++) {
        for (let cx = x0; cx <= x1; cx++) {
          const cxm = cx * this.cellW + this.cellW / 2;
          const cym = cy * this.cellH + this.cellH / 2;
          if ((cxm - p.x) * (cxm - p.x) + (cym - p.y) * (cym - p.y) <= r2) {
            const i = cy * this.cols + cx;
            this.ghostProb[i] *= 0.2;
          }
        }
      }
      this.normalizeGhosts();
    }
    /** Normalize probabilities to sum to 1 */
    normalizeGhosts() {
      let sum = 0;
      for (const v of this.ghostProb) sum += v;
      if (sum <= 0) return;
      for (let i = 0; i < this.ghostProb.length; i++) this.ghostProb[i] /= sum;
    }
    normalizeCorridors() {
      let sum = 0;
      for (const v of this.corridorProb) sum += v;
      if (sum <= 0) return;
      for (let i = 0; i < this.corridorProb.length; i++) this.corridorProb[i] /= sum;
    }
    /** Center points of top-N cells by probability (descending) */
    topGhostCells(n = 1) {
      const cells = this.ghostProb.map((prob, idx) => ({ prob, idx })).filter((c) => c.prob > 0).sort((a, b) => b.prob - a.prob).slice(0, n);
      return cells.map(({ prob, idx }) => {
        const cy = Math.floor(idx / this.cols);
        const cx = idx % this.cols;
        return { center: centerOfCell(cx, cy, this.cellW, this.cellH), prob };
      });
    }
    /** Probability lookup for a point */
    ghostProbAt(p) {
      return this.ghostProb[this.idxFromPoint(p)];
    }
    corridorProbAt(p) {
      return this.corridorProb[this.idxFromPoint(p)];
    }
    /** Return center of least-visited cell (simple frontier heuristic) */
    bestFrontier() {
      let bestI = 0, bestV = this.visits[0];
      for (let i = 1; i < this.visits.length; i++) {
        if (this.visits[i] < bestV) {
          bestV = this.visits[i];
          bestI = i;
        }
      }
      const cy = Math.floor(bestI / this.cols);
      const cx = bestI % this.cols;
      return centerOfCell(cx, cy, this.cellW, this.cellH);
    }
    pruneEnemies(currentTick, maxAge = this.enemyMaxAge) {
      for (const [id, e] of this.enemies) {
        if (currentTick - e.lastTick > maxAge) this.enemies.delete(id);
      }
    }
    trackEnemies(enemies, tick2) {
      if (!enemies) return;
      for (const e of enemies) {
        if ((e == null ? void 0 : e.x) === void 0 || (e == null ? void 0 : e.y) === void 0) continue;
        const prev = this.enemies.get(e.id);
        const prevPos = prev == null ? void 0 : prev.last;
        const dt = prev && tick2 !== void 0 ? tick2 - prev.lastTick : 0;
        const vel = prevPos && dt > 0 ? { x: (e.x - prevPos.x) / dt, y: (e.y - prevPos.y) / dt } : prev == null ? void 0 : prev.vel;
        this.enemies.set(e.id, {
          id: e.id,
          last: { x: e.x, y: e.y },
          prev: prevPos,
          vel,
          lastTick: tick2 != null ? tick2 : 0,
          carrying: e.carrying !== void 0,
          stunCd: e.stunCd
        });
      }
      if (tick2 !== void 0) this.pruneEnemies(tick2);
    }
    /** Assign or update roles for our busters */
    updateRoles(allies = []) {
      if (!allies.length) return;
      const scoutId = allies.map((a) => a.id).sort((a, b) => a - b)[0];
      for (const a of allies) {
        let role = "CHASER";
        if (a.carrying !== void 0) role = "CARRIER";
        else if (a.id === scoutId) role = "SCOUT";
        this.roles.set(a.id, role);
      }
    }
    roleOf(id) {
      var _a;
      return (_a = this.roles.get(id)) != null ? _a : "CHASER";
    }
  };
  function predictEnemyPath(e, base, ticks) {
    const path = [];
    let cur = { ...e.last };
    let v = e.vel;
    for (let i = 0; i < ticks; i++) {
      if (!v) {
        const dx = base.x - cur.x, dy = base.y - cur.y;
        const d2 = Math.hypot(dx, dy) || 1;
        v = { x: dx / d2 * RULES.MOVE_SPEED, y: dy / d2 * RULES.MOVE_SPEED };
      }
      cur = { x: cur.x + v.x, y: cur.y + v.y };
      path.push({ x: Math.round(cur.x), y: Math.round(cur.y) });
      const bx = base.x - cur.x, by = base.y - cur.y;
      if (Math.hypot(bx, by) <= RULES.MOVE_SPEED) break;
      if (v.x * bx + v.y * by <= 0) v = void 0;
    }
    return path;
  }
  var G = globalThis.__HYBRID_STATE__ || (globalThis.__HYBRID_STATE__ = {});
  function getState(ctx2, obs) {
    const key = "team";
    if (!G[key] || (obs == null ? void 0 : obs.tick) <= 1) {
      G[key] = new HybridState(ctx2 == null ? void 0 : ctx2.bounds, 8, 5, DEFAULT_ENEMY_MAX_AGE, ctx2 == null ? void 0 : ctx2.ghostSpawns);
    }
    return G[key];
  }

  // micro.ts
  var { performance } = globalThis;
  var microPerf = {
    twoTurnMs: 0,
    twoTurnCalls: 0,
    interceptMs: 0,
    interceptCalls: 0,
    ejectMs: 0,
    ejectCalls: 0
  };
  var MICRO_BUDGET_MS = 0.5;
  function resetMicroPerf() {
    microPerf.twoTurnMs = 0;
    microPerf.twoTurnCalls = 0;
    microPerf.interceptMs = 0;
    microPerf.interceptCalls = 0;
    microPerf.ejectMs = 0;
    microPerf.ejectCalls = 0;
    twoTurnContestCache.clear();
    twoTurnInterceptCache.clear();
    twoTurnEjectCache.clear();
  }
  function microOverBudget() {
    return microPerf.twoTurnMs + microPerf.interceptMs + microPerf.ejectMs >= MICRO_BUDGET_MS;
  }
  var twoTurnContestCache = /* @__PURE__ */ new Map();
  var twoTurnInterceptCache = /* @__PURE__ */ new Map();
  var twoTurnEjectCache = /* @__PURE__ */ new Map();
  var SPEED = RULES.MOVE_SPEED;
  function dist2(ax, ay, bx, by) {
    return Math.hypot(ax - bx, ay - by);
  }
  function step(p, q) {
    const dx = q.x - p.x, dy = q.y - p.y;
    const d2 = Math.hypot(dx, dy);
    if (d2 <= SPEED) return { x: q.x, y: q.y };
    return { x: p.x + dx / d2 * SPEED, y: p.y + dy / d2 * SPEED };
  }
  function estimateInterceptPoint(me, enemy, myBase2) {
    const ex = enemy.x, ey = enemy.y;
    const bx = myBase2.x, by = myBase2.y;
    const dx = bx - ex, dy = by - ey;
    const L = Math.hypot(dx, dy) || 1;
    const ts = [0.15, 0.3, 0.45, 0.6, 0.75, 0.9];
    let best = { x: ex + dx * 0.6, y: ey + dy * 0.6 };
    for (const t of ts) {
      const px = ex + dx * t, py = ey + dy * t;
      const tMe = dist2(me.x, me.y, px, py) / SPEED;
      const tEn = L * t / SPEED;
      if (tMe <= tEn) {
        best = { x: Math.round(px), y: Math.round(py) };
        break;
      }
    }
    return best;
  }
  function duelStunDelta(opts) {
    if (microOverBudget()) return 0;
    const { me, enemy, canStunMe, canStunEnemy, stunRange } = opts;
    const me1 = step(me, enemy);
    const enemy1 = step(enemy, me);
    const r = dist2(me1.x, me1.y, enemy1.x, enemy1.y);
    if (r > stunRange) return 0;
    if (canStunMe && !canStunEnemy) return 1;
    if (!canStunMe && canStunEnemy) return -1;
    if (canStunMe && canStunEnemy) return 0.15;
    return 0;
  }
  function contestedBustDelta(opts) {
    if (microOverBudget()) return 0;
    const { me, ghost, enemies, bustMin, bustMax, stunRange, canStunMe } = opts;
    const me1 = step(me, ghost);
    const enemies1 = enemies.map((e) => step(e, ghost));
    const r = dist2(me1.x, me1.y, ghost.x, ghost.y);
    const near = enemies1.filter((e) => dist2(e.x, e.y, ghost.x, ghost.y) <= 2200);
    if (near.length === 0) return r >= bustMin && r <= bustMax ? 0.25 : 0;
    let delta = 0;
    if (r >= bustMin && r <= bustMax) delta += 0.25;
    delta += -0.35 * near.length;
    const enemyInStun = near.some((e) => dist2(me1.x, me1.y, e.x, e.y) <= stunRange);
    if (enemyInStun && !canStunMe) delta -= 0.3;
    return delta;
  }
  function twoTurnContestDelta(opts) {
    microPerf.twoTurnCalls++;
    if (microOverBudget()) return 0;
    const key = JSON.stringify(opts);
    const cached = twoTurnContestCache.get(key);
    if (cached !== void 0) return cached;
    const t0 = performance.now();
    const { me, enemy, ghost, bustMin, bustMax, stunRange, canStunMe, canStunEnemy } = opts;
    const me1 = step(me, ghost != null ? ghost : enemy);
    const enemy1 = step(enemy, ghost != null ? ghost : me);
    let delta = duelStunDelta({
      me: me1,
      enemy: enemy1,
      canStunMe,
      canStunEnemy,
      stunRange
    });
    if (ghost) {
      delta += contestedBustDelta({
        me: me1,
        ghost,
        enemies: [enemy1],
        bustMin,
        bustMax,
        stunRange,
        canStunMe
      });
    }
    microPerf.twoTurnMs += performance.now() - t0;
    twoTurnContestCache.set(key, delta);
    return delta;
  }
  function interceptDelta(opts) {
    if (microOverBudget()) return 0;
    const { me, enemy, myBase: myBase2 } = opts;
    const P = estimateInterceptPoint(me, enemy, myBase2);
    const tMe = dist2(me.x, me.y, P.x, P.y) / SPEED;
    const tEn = dist2(enemy.x, enemy.y, P.x, P.y) / SPEED;
    return (tEn - tMe) * 0.2;
  }
  function twoTurnInterceptDelta(opts) {
    microPerf.interceptCalls++;
    if (microOverBudget()) return 0;
    const key = JSON.stringify(opts);
    const cached = twoTurnInterceptCache.get(key);
    if (cached !== void 0) return cached;
    const t0 = performance.now();
    const { me, enemy, myBase: myBase2, stunRange, canStunMe, canStunEnemy } = opts;
    const P = estimateInterceptPoint(me, enemy, myBase2);
    const me1 = step(me, P);
    const enemy1 = step(enemy, myBase2);
    let delta = interceptDelta({ me: me1, enemy: enemy1, myBase: myBase2 });
    delta += duelStunDelta({ me: me1, enemy: enemy1, canStunMe, canStunEnemy, stunRange });
    microPerf.interceptMs += performance.now() - t0;
    twoTurnInterceptCache.set(key, delta);
    return delta;
  }
  function releaseBlockDelta(opts) {
    if (microOverBudget()) return 0;
    const { blocker, carrier, myBase: myBase2, stunRange } = opts;
    const carrier1 = step(carrier, myBase2);
    const dCarrierToBase = dist2(carrier1.x, carrier1.y, myBase2.x, myBase2.y);
    const RELEASE_DIST = 1600;
    const need = Math.max(0, dCarrierToBase - (RELEASE_DIST + 150));
    const ux = myBase2.x - carrier1.x, uy = myBase2.y - carrier1.y;
    const L = Math.hypot(ux, uy) || 1;
    const px = carrier1.x + ux / L * need, py = carrier1.y + uy / L * need;
    const blocker1 = step(blocker, { x: px, y: py });
    const tMe = dist2(blocker1.x, blocker1.y, px, py) / SPEED;
    const tEn = need / SPEED;
    const lead = tEn - tMe;
    let delta = 0;
    if (lead < -1) delta -= 0.6;
    else if (lead > 0.5) delta += 0.6;
    const dr = dist2(blocker1.x, blocker1.y, px, py);
    if (dr <= stunRange + 200) delta += 0.25;
    return delta;
  }
  function ejectDelta(opts) {
    if (microOverBudget()) return 0;
    const { me, target, myBase: myBase2, ally } = opts;
    const before = dist2(me.x, me.y, myBase2.x, myBase2.y);
    const after = dist2(target.x, target.y, myBase2.x, myBase2.y);
    let delta = (before - after) * 1e-3;
    if (ally) {
      const meTo = dist2(me.x, me.y, target.x, target.y);
      const allyTo = dist2(ally.x, ally.y, target.x, target.y);
      if (allyTo < meTo) delta += 0.25;
    }
    return delta;
  }
  function twoTurnEjectDelta(opts) {
    microPerf.ejectCalls++;
    if (microOverBudget()) return 0;
    const key = JSON.stringify(opts);
    const cached = twoTurnEjectCache.get(key);
    if (cached !== void 0) return cached;
    const t0 = performance.now();
    const { me, enemy, target, myBase: myBase2, stunRange, canStunEnemy } = opts;
    const me1 = step(me, target);
    const enemy1 = step(enemy, target);
    let delta = ejectDelta({ me: me1, target, myBase: myBase2 });
    const r = dist2(enemy1.x, enemy1.y, target.x, target.y);
    if (r <= stunRange && canStunEnemy) delta -= 0.5;
    microPerf.ejectMs += performance.now() - t0;
    twoTurnEjectCache.set(key, delta);
    return delta;
  }
  function scoreCandidate(c) {
    const micro2 = c.deltas ? c.deltas.reduce((s, v) => s + v, 0) : 0;
    return c.base + micro2;
  }

  // hungarian.ts
  function hungarian(cost) {
    var _a, _b;
    const n = cost.length;
    const m0 = (_b = (_a = cost[0]) == null ? void 0 : _a.length) != null ? _b : 0;
    if (n === 0 || m0 === 0) return [];
    let m = m0;
    if (m < n) m = n;
    const BIG = 1e9;
    const a = new Array(n);
    for (let i = 0; i < n; i++) {
      a[i] = new Array(m);
      for (let j = 0; j < m; j++) {
        a[i][j] = j < m0 ? cost[i][j] : BIG;
      }
    }
    const u = new Array(n + 1).fill(0);
    const v = new Array(m + 1).fill(0);
    const p = new Array(m + 1).fill(0);
    const way = new Array(m + 1).fill(0);
    for (let i = 1; i <= n; i++) {
      p[0] = i;
      const minv = new Array(m + 1).fill(Infinity);
      const used = new Array(m + 1).fill(false);
      let j0 = 0;
      do {
        used[j0] = true;
        const i0 = p[j0];
        let delta = Infinity;
        let j1 = 0;
        for (let j = 1; j <= m; j++) {
          if (used[j]) continue;
          const cur = a[i0 - 1][j - 1] - u[i0] - v[j];
          if (cur < minv[j]) {
            minv[j] = cur;
            way[j] = j0;
          }
          if (minv[j] < delta) {
            delta = minv[j];
            j1 = j;
          }
        }
        for (let j = 0; j <= m; j++) {
          if (used[j]) {
            u[p[j]] += delta;
            v[j] -= delta;
          } else {
            minv[j] -= delta;
          }
        }
        j0 = j1;
      } while (p[j0] !== 0);
      do {
        const j1 = way[j0];
        p[j0] = p[j1];
        j0 = j1;
      } while (j0 !== 0);
    }
    const res = new Array(n).fill(-1);
    for (let j = 1; j <= m; j++) {
      if (p[j] > 0) {
        const i = p[j] - 1;
        const col = j - 1;
        res[i] = col < m0 ? col : -1;
      }
    }
    return res;
  }

  // ../shared/src/vec.ts
  function clamp3(v, lo, hi) {
    return Math.max(lo, Math.min(hi, v));
  }
  function dist3(ax, ay, bx, by) {
    return Math.hypot(ax - bx, ay - by);
  }
  function norm(dx, dy) {
    const d2 = Math.hypot(dx, dy) || 1;
    return [dx / d2, dy / d2];
  }

  // hybrid-bot.ts
  var micro = (fn) => microOverBudget() ? 0 : fn();
  var fog = new Fog();
  var TUNE2 = TUNE;
  var WEIGHTS2 = WEIGHTS;
  var W2 = 16e3;
  var H2 = 9e3;
  var BUST_MIN = 900;
  var BUST_MAX = 1760;
  var STUN_CD = 20;
  var EJECT_MAX = 1760;
  var PREDICT_TICKS = 3;
  function dbg(act2, tag, reason, extra) {
    act2.__dbg = { tag, reason, extra };
    return act2;
  }
  var mem = /* @__PURE__ */ new Map();
  function M(id) {
    if (!mem.has(id)) mem.set(id, { stunReadyAt: 0, radarUsed: false, wp: 0 });
    return mem.get(id);
  }
  var lastTick = Infinity;
  var PATROLS = [
    [{ x: 2500, y: 2500 }, { x: 12e3, y: 2e3 }, { x: 15e3, y: 8e3 }, { x: 2e3, y: 8e3 }, { x: 8e3, y: 4500 }],
    [{ x: 13500, y: 6500 }, { x: 8e3, y: 1200 }, { x: 1200, y: 1200 }, { x: 8e3, y: 7800 }, { x: 8e3, y: 4500 }],
    [{ x: 8e3, y: 4500 }, { x: 14e3, y: 4500 }, { x: 8e3, y: 8e3 }, { x: 1e3, y: 4500 }, { x: 8e3, y: 1e3 }],
    [{ x: 2e3, y: 7e3 }, { x: 14e3, y: 7e3 }, { x: 14e3, y: 2e3 }, { x: 2e3, y: 2e3 }, { x: 8e3, y: 4500 }]
  ];
  function resolveBases(ctx2) {
    var _a, _b;
    const my = (_a = ctx2.myBase) != null ? _a : { x: 0, y: 0 };
    const enemy = (_b = ctx2.enemyBase) != null ? _b : { x: W2 - my.x, y: H2 - my.y };
    return { my, enemy };
  }
  function spacedTarget(me, raw, friends) {
    if (!friends || friends.length <= 1) {
      const phase = (me.id * 9301 ^ 40503) & 1 ? 1 : -1;
      const [dx, dy] = norm(raw.x - me.x, raw.y - me.y);
      const px = -dy, py = dx;
      return { x: clamp3(raw.x + phase * 220 * px, 0, W2), y: clamp3(raw.y + phase * 220 * py, 0, H2) };
    }
    let nearest, best = Infinity;
    for (const f of friends) {
      if (f.id === me.id) continue;
      const d2 = dist3(me.x, me.y, f.x, f.y);
      if (d2 < best) {
        best = d2;
        nearest = f;
      }
    }
    if (!nearest || best >= TUNE2.SPACING) return raw;
    const [ax, ay] = norm(me.x - nearest.x, me.y - nearest.y);
    return { x: clamp3(raw.x + ax * TUNE2.SPACING_PUSH, 0, W2), y: clamp3(raw.y + ay * TUNE2.SPACING_PUSH, 0, H2) };
  }
  function blockerRing(myBase2, enemyBase2) {
    const [vx, vy] = norm(enemyBase2.x - myBase2.x, enemyBase2.y - myBase2.y);
    return { x: clamp3(enemyBase2.x - vx * TUNE2.BLOCK_RING, 0, W2), y: clamp3(enemyBase2.y - vy * TUNE2.BLOCK_RING, 0, H2) };
  }
  var planTick = -1;
  var planAssign = /* @__PURE__ */ new Map();
  function uniqTeam(self, friends) {
    const map = /* @__PURE__ */ new Map();
    map.set(self.id, self);
    (friends != null ? friends : []).forEach((f) => map.set(f.id, f));
    return Array.from(map.values());
  }
  function buildTasks(ctx2, meObs, state, MY, EN) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const tasks = [];
    const enemies = (_a = meObs.enemies) != null ? _a : [];
    const ghosts = (_b = meObs.ghostsVisible) != null ? _b : [];
    const team = uniqTeam(meObs.self, meObs.friends);
    const tick2 = (_d = (_c = ctx2.tick) != null ? _c : meObs.tick) != null ? _d : 0;
    for (const e of enemies) {
      if (e.state === 1) {
        const tx = Math.round((e.x + MY.x) / 2);
        const ty = Math.round((e.y + MY.y) / 2);
        tasks.push({ type: "INTERCEPT", target: { x: tx, y: ty }, payload: { enemyId: e.id }, baseScore: WEIGHTS2.INTERCEPT_BASE });
      }
    }
    for (const e of state.enemies.values()) {
      if (e.carrying && !enemies.some((v) => v.id === e.id)) {
        const path = predictEnemyPath(e, MY, PREDICT_TICKS);
        for (const p of path) {
          const tx = Math.round((p.x + MY.x) / 2);
          const ty = Math.round((p.y + MY.y) / 2);
          tasks.push({ type: "INTERCEPT", target: { x: tx, y: ty }, payload: { enemyId: e.id }, baseScore: WEIGHTS2.INTERCEPT_BASE });
        }
      }
    }
    let nearThreat = enemies.find((e) => dist3(e.x, e.y, MY.x, MY.y) <= TUNE2.DEFEND_RADIUS);
    if (!nearThreat) {
      for (const e of state.enemies.values()) {
        if (dist3(e.last.x, e.last.y, MY.x, MY.y) <= TUNE2.DEFEND_RADIUS) {
          nearThreat = { id: e.id, x: e.last.x, y: e.last.y };
          break;
        }
      }
    }
    if (nearThreat) {
      const tx = Math.round((nearThreat.x + MY.x) / 2);
      const ty = Math.round((nearThreat.y + MY.y) / 2);
      tasks.push({ type: "DEFEND", target: { x: tx, y: ty }, payload: { enemyId: nearThreat.id }, baseScore: WEIGHTS2.DEFEND_BASE + WEIGHTS2.DEFEND_NEAR_BONUS });
    }
    for (const g of ghosts) {
      const r = (_e = g.range) != null ? _e : dist3(meObs.self.x, meObs.self.y, g.x, g.y);
      const onRingBonus = r >= BUST_MIN && r <= BUST_MAX ? WEIGHTS2.BUST_RING_BONUS : 0;
      const risk = enemies.filter((e) => dist3(e.x, e.y, g.x, g.y) <= 2200).length * WEIGHTS2.BUST_ENEMY_NEAR_PEN;
      tasks.push({ type: "BUST", target: { x: g.x, y: g.y }, payload: { ghostId: g.id }, baseScore: WEIGHTS2.BUST_BASE + onRingBonus - risk });
      const alliesNear = team.filter((f) => dist3(f.x, f.y, g.x, g.y) <= BUST_MAX);
      const enemiesNear = enemies.filter((e) => dist3(e.x, e.y, g.x, g.y) <= 2200);
      if (alliesNear.length && enemiesNear.length) {
        tasks.push({
          type: "SUPPORT",
          target: { x: g.x, y: g.y },
          payload: { ghostId: g.id, allyIds: alliesNear.map((a) => a.id) },
          baseScore: WEIGHTS2.SUPPORT_BASE + enemiesNear.length
        });
      }
    }
    for (const e of enemies) {
      const alliesNear = team.filter((f) => f.id !== e.id && dist3(f.x, f.y, e.x, e.y) <= TUNE2.STUN_RANGE);
      const ready = alliesNear.some((a) => M(a.id).stunReadyAt <= tick2);
      if (alliesNear.length && ready && (e.state !== 2 || ((_f = e.stunnedFor) != null ? _f : 0) <= 2)) {
        tasks.push({
          type: "SUPPORT",
          target: { x: e.x, y: e.y },
          payload: { enemyId: e.id, allyIds: alliesNear.map((a) => a.id) },
          baseScore: WEIGHTS2.SUPPORT_BASE + alliesNear.length
        });
      }
    }
    for (const mate of team) {
      const isCarrying = mate.carrying !== void 0 || mate.state === 1;
      if (!isCarrying) continue;
      const mid = { x: Math.round((mate.x + MY.x) / 2), y: Math.round((mate.y + MY.y) / 2) };
      const near = enemies.filter((e) => dist3(e.x, e.y, mid.x, mid.y) <= 2200).length;
      const baseScore = WEIGHTS2.CARRY_BASE - near * WEIGHTS2.CARRY_ENEMY_NEAR_PEN;
      tasks.push({ type: "CARRY", target: mid, payload: { id: mate.id }, baseScore });
    }
    if (!enemies.some((e) => e.state === 1) && !Array.from(state.enemies.values()).some((e) => e.carrying)) {
      tasks.push({ type: "BLOCK", target: blockerRing(MY, EN), baseScore: WEIGHTS2.BLOCK_BASE });
    }
    const early = ((_h = (_g = ctx2.tick) != null ? _g : meObs.tick) != null ? _h : 0) < 5;
    for (const mate of team) {
      let target;
      let baseScore = WEIGHTS2.EXPLORE_BASE + TUNE2.EXPLORE_STEP_REWARD;
      const payload = { id: mate.id };
      if (!early) {
        const fr = fog.frontier(mate);
        target = fr.target;
        baseScore += fr.score * 1e-5;
      }
      if (!target) {
        const idx = ((_i = mate.localIndex) != null ? _i : 0) % PATROLS.length;
        const Mx = MPatrol(mate.id);
        const path = PATROLS[idx];
        const wp = Mx.wp % path.length;
        target = path[wp];
        payload.wp = wp;
      }
      const prob = fog.probAt(target);
      baseScore += prob * 100;
      if (state.roleOf(mate.id) === "SCOUT") baseScore += 5;
      tasks.push({ type: "EXPLORE", target, payload, baseScore });
    }
    return tasks;
  }
  var pMem = /* @__PURE__ */ new Map();
  function MPatrol(id) {
    if (!pMem.has(id)) pMem.set(id, { wp: 0 });
    return pMem.get(id);
  }
  function scoreAssign(b, t, enemies, MY, tick2, state) {
    var _a, _b, _c, _d, _e;
    const baseD = dist3(b.x, b.y, t.target.x, t.target.y);
    let s = t.baseScore - baseD * WEIGHTS2.DIST_PEN;
    const canStunMe = M(b.id).stunReadyAt <= tick2;
    if (t.type === "INTERCEPT") {
      const enemy = enemies.find((e) => {
        var _a2;
        return e.id === ((_a2 = t.payload) == null ? void 0 : _a2.enemyId);
      });
      if (enemy) {
        const P = estimateInterceptPoint(b, enemy, MY);
        const d2 = dist3(b.x, b.y, P.x, P.y);
        s = t.baseScore - d2 * WEIGHTS2.DIST_PEN - d2 * WEIGHTS2.INTERCEPT_DIST_PEN;
        s += micro(() => duelStunDelta({ me: b, enemy, canStunMe, canStunEnemy: enemy.state !== 2, stunRange: TUNE2.STUN_RANGE }));
        s += micro(() => interceptDelta({ me: b, enemy, myBase: MY }));
        s += micro(() => releaseBlockDelta({ blocker: b, carrier: enemy, myBase: MY, stunRange: TUNE2.STUN_RANGE }));
        const near = ((_a = enemy.range) != null ? _a : dist3(b.x, b.y, enemy.x, enemy.y)) <= 2500;
        const threat = enemy.state === 1 && dist3(enemy.x, enemy.y, MY.x, MY.y) <= TUNE2.RELEASE_DIST + 2e3;
        if (near || threat) {
          s += micro(
            () => twoTurnInterceptDelta({
              me: b,
              enemy,
              myBase: MY,
              stunRange: TUNE2.STUN_RANGE,
              canStunMe,
              canStunEnemy: enemy.state !== 2
            })
          );
        }
      } else {
        s -= baseD * WEIGHTS2.INTERCEPT_DIST_PEN;
      }
    }
    if (t.type === "BUST") {
      const r = dist3(b.x, b.y, t.target.x, t.target.y);
      if (r >= BUST_MIN && r <= BUST_MAX) s += WEIGHTS2.BUST_RING_BONUS * 0.5;
      s += micro(
        () => {
          var _a2;
          return contestedBustDelta({
            me: b,
            ghost: { x: t.target.x, y: t.target.y, id: (_a2 = t.payload) == null ? void 0 : _a2.ghostId },
            enemies,
            bustMin: BUST_MIN,
            bustMax: BUST_MAX,
            stunRange: TUNE2.STUN_RANGE,
            canStunMe
          });
        }
      );
      const close = enemies.filter((e) => dist3(e.x, e.y, t.target.x, t.target.y) <= 2500);
      for (const e of close) {
        if (microOverBudget()) break;
        s += micro(
          () => {
            var _a2;
            return twoTurnContestDelta({
              me: b,
              enemy: e,
              ghost: { x: t.target.x, y: t.target.y, id: (_a2 = t.payload) == null ? void 0 : _a2.ghostId },
              bustMin: BUST_MIN,
              bustMax: BUST_MAX,
              stunRange: TUNE2.STUN_RANGE,
              canStunMe,
              canStunEnemy: e.state !== 2
            });
          }
        );
      }
    }
    if (t.type === "SUPPORT") {
      const enemiesNear = enemies.filter((e) => dist3(e.x, e.y, t.target.x, t.target.y) <= 2200).length;
      const allies = (_d = (_c = (_b = t.payload) == null ? void 0 : _b.allyIds) == null ? void 0 : _c.length) != null ? _d : 0;
      s += (enemiesNear - allies) * (WEIGHTS2.DEFEND_NEAR_BONUS * 0.5);
      if (canStunMe) s += WEIGHTS2.DEFEND_NEAR_BONUS;
    }
    if (t.type === "CARRY") {
      const homeD = dist3(b.x, b.y, MY.x, MY.y);
      const midRisk = enemies.filter((e) => dist3(e.x, e.y, t.target.x, t.target.y) <= 2200).length;
      s -= (homeD - baseD) * WEIGHTS2.DIST_PEN;
      s -= midRisk * WEIGHTS2.CARRY_ENEMY_NEAR_PEN;
      if (((_e = t.payload) == null ? void 0 : _e.id) === b.id) s += 2;
    }
    if (t.type === "BLOCK") {
      const carrier = enemies.find((e) => e.state === 1);
      if (carrier) {
        s += micro(() => releaseBlockDelta({ blocker: b, carrier, myBase: MY, stunRange: TUNE2.STUN_RANGE }));
        if (dist3(carrier.x, carrier.y, MY.x, MY.y) <= TUNE2.RELEASE_DIST + 2e3) {
          s += micro(
            () => twoTurnContestDelta({
              me: b,
              enemy: carrier,
              bustMin: BUST_MIN,
              bustMax: BUST_MAX,
              stunRange: TUNE2.STUN_RANGE,
              canStunMe,
              canStunEnemy: carrier.state !== 2
            })
          );
        }
      }
    }
    if (t.type === "DEFEND") {
      const near = enemies.filter((e) => dist3(e.x, e.y, MY.x, MY.y) <= TUNE2.DEFEND_RADIUS).length;
      s += near * 1.5;
    }
    const role = state.roleOf(b.id);
    if (role === "SCOUT" && t.type === "EXPLORE") s += 5;
    if (role === "CHASER" && t.type === "BUST") s += 5;
    if (role === "INTERCEPT" && t.type === "INTERCEPT") s += 5;
    if (role === "BLOCK" && t.type === "BLOCK") s += 5;
    return s;
  }
  function runAuction(team, tasks, enemies, MY, tick2, state) {
    const assigned = /* @__PURE__ */ new Map();
    if (team.length && tasks.length && team.length * tasks.length <= 100) {
      const cost = team.map(
        (b) => tasks.map((t) => -scoreAssign(b, t, enemies, MY, tick2, state))
      );
      const match = hungarian(cost);
      for (let i = 0; i < team.length; i++) {
        const ti = match[i];
        if (ti >= 0 && ti < tasks.length) {
          assigned.set(team[i].id, tasks[ti]);
        }
      }
      return assigned;
    }
    const freeB = new Set(team.map((b) => b.id));
    const freeT = new Set(tasks.map((_, i) => i));
    const S = [];
    for (let bi = 0; bi < team.length; bi++) {
      for (let ti = 0; ti < tasks.length; ti++) {
        S.push({ b: bi, t: ti, s: scoreAssign(team[bi], tasks[ti], enemies, MY, tick2, state) });
      }
    }
    S.sort((a, b) => b.s - a.s);
    for (const { b, t } of S) {
      const bId = team[b].id;
      if (!freeB.has(bId) || !freeT.has(t)) continue;
      assigned.set(bId, tasks[t]);
      freeB.delete(bId);
      freeT.delete(t);
      if (freeB.size === 0) break;
    }
    return assigned;
  }
  function act(ctx2, obs) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    resetMicroPerf();
    const tick2 = ((_b = (_a = ctx2.tick) != null ? _a : obs.tick) != null ? _b : 0) | 0;
    if (tick2 <= 1 && tick2 < lastTick) {
      mem.clear();
      pMem.clear();
      planTick = -1;
      planAssign.clear();
      fog.reset();
    }
    lastTick = tick2;
    const me = obs.self;
    const finish = (act2) => {
      if (process.env.MICRO_TIMING) {
        console.log(`[micro] t=${tick2} b=${me.id} twoTurn=${microPerf.twoTurnMs.toFixed(3)}ms calls=${microPerf.twoTurnCalls}`);
      }
      return act2;
    };
    const m = M(me.id);
    const state = getState(ctx2, obs);
    state.trackEnemies(obs.enemies, tick2);
    state.decayGhosts();
    state.diffuseGhosts();
    fog.beginTick(tick2);
    const friends = uniqTeam(me, obs.friends);
    for (const f of friends) {
      fog.markVisited(f);
      state.touchVisit(f);
      state.subtractSeen(f, 400);
    }
    state.updateRoles(friends);
    const { my: MY, enemy: EN } = resolveBases(ctx2);
    const enemiesObs = ((_c = obs.enemies) != null ? _c : []).slice().sort((a, b) => {
      var _a2, _b2;
      return ((_a2 = a.range) != null ? _a2 : dist3(me.x, me.y, a.x, a.y)) - ((_b2 = b.range) != null ? _b2 : dist3(me.x, me.y, b.x, b.y));
    });
    const ghosts = ((_d = obs.ghostsVisible) != null ? _d : []).slice().sort((a, b) => {
      var _a2, _b2;
      return ((_a2 = a.range) != null ? _a2 : dist3(me.x, me.y, a.x, a.y)) - ((_b2 = b.range) != null ? _b2 : dist3(me.x, me.y, b.x, b.y));
    });
    const remembered = Array.from(state.enemies.values()).map((e) => ({ id: e.id, x: e.last.x, y: e.last.y, state: e.carrying ? 1 : 0 }));
    const enemyMap = /* @__PURE__ */ new Map();
    for (const e of enemiesObs) enemyMap.set(e.id, e);
    for (const e of remembered) if (!enemyMap.has(e.id)) enemyMap.set(e.id, e);
    const enemiesAll = Array.from(enemyMap.values()).sort((a, b) => {
      var _a2, _b2;
      return ((_a2 = a.range) != null ? _a2 : dist3(me.x, me.y, a.x, a.y)) - ((_b2 = b.range) != null ? _b2 : dist3(me.x, me.y, b.x, b.y));
    });
    const enemies = enemiesObs;
    if (enemies.length || ghosts.length) {
      fog.clearCircle(me, 2200);
      state.subtractSeen(me, 2200);
    }
    for (const g of ghosts) {
      fog.bumpGhost(g.x, g.y);
    }
    if (ghosts.length) state.updateGhosts(ghosts.map((g) => ({ x: g.x, y: g.y })));
    const bpp = (_e = ctx2.bustersPerPlayer) != null ? _e : Math.max(3, friends.length || 3);
    me.localIndex = (_f = me.localIndex) != null ? _f : me.id % bpp;
    const localIdx = me.localIndex;
    const carrying = me.carrying !== void 0 ? true : me.state === 1;
    const stunned = me.state === 2;
    const stunCdLeft = (_g = me.stunCd) != null ? _g : Math.max(0, m.stunReadyAt - tick2);
    const canStun = !stunned && stunCdLeft <= 0;
    if (carrying) {
      const dHome = dist3(me.x, me.y, MY.x, MY.y);
      if (dHome > TUNE2.RELEASE_DIST) {
        const threat = enemies.find((e) => {
          var _a2;
          return ((_a2 = e.stunnedFor) != null ? _a2 : 0) <= 0 && dist3(e.x, e.y, me.x, me.y) <= TUNE2.STUN_RANGE;
        });
        let handoff;
        for (const f of friends) {
          if (f.id === me.id) continue;
          if (dist3(f.x, f.y, me.x, me.y) <= EJECT_MAX && dist3(f.x, f.y, MY.x, MY.y) + 400 < dHome) {
            handoff = f;
            break;
          }
        }
        if (!canStun && threat || handoff) {
          const target = handoff != null ? handoff : MY;
          const [dx, dy] = norm(target.x - me.x, target.y - me.y);
          const tx = clamp3(me.x + dx * EJECT_MAX, 0, W2);
          const ty = clamp3(me.y + dy * EJECT_MAX, 0, H2);
          return finish(dbg({ type: "EJECT", x: tx, y: ty }, "EJECT", handoff ? "handoff" : "threat"));
        }
      }
    }
    let targetEnemy = enemies.find((e) => {
      var _a2, _b2;
      return e.state === 1 && ((_a2 = e.stunnedFor) != null ? _a2 : 0) <= 0 && ((_b2 = e.range) != null ? _b2 : dist3(me.x, me.y, e.x, e.y)) <= TUNE2.STUN_RANGE;
    });
    if (!targetEnemy) {
      const cand = enemies.find((e) => {
        var _a2, _b2;
        return e.state !== 2 && ((_a2 = e.stunnedFor) != null ? _a2 : 0) <= 0 && ((_b2 = e.range) != null ? _b2 : dist3(me.x, me.y, e.x, e.y)) <= BUST_MAX;
      });
      if (cand) targetEnemy = cand;
    }
    if (canStun && targetEnemy) {
      const duel = micro(
        () => duelStunDelta({
          me,
          enemy: targetEnemy,
          canStunMe: true,
          canStunEnemy: targetEnemy.state !== 2,
          stunRange: TUNE2.STUN_RANGE
        })
      ) + (targetEnemy.state === 1 ? micro(() => releaseBlockDelta({ blocker: me, carrier: targetEnemy, myBase: MY, stunRange: TUNE2.STUN_RANGE })) : 0);
      if (duel >= 0) {
        mem.get(me.id).stunReadyAt = tick2 + STUN_CD;
        return finish(dbg({ type: "STUN", busterId: targetEnemy.id }, "STUN", targetEnemy.state === 1 ? "enemy_carrier" : "threat"));
      }
    }
    if (!m.radarUsed && !stunned) {
      if (localIdx === 0 && tick2 === TUNE2.RADAR1_TURN) {
        m.radarUsed = true;
        fog.clearCircle(me, 4e3);
        return finish(dbg({ type: "RADAR" }, "RADAR", "RADAR1_TURN"));
      }
      if (localIdx === 1 && tick2 === TUNE2.RADAR2_TURN) {
        m.radarUsed = true;
        fog.clearCircle(me, 4e3);
        return finish(dbg({ type: "RADAR" }, "RADAR", "RADAR2_TURN"));
      }
    }
    if (ghosts.length) {
      const g = ghosts[0];
      const r = (_h = g.range) != null ? _h : dist3(me.x, me.y, g.x, g.y);
      if (r >= BUST_MIN && r <= BUST_MAX) return finish(dbg({ type: "BUST", ghostId: g.id }, "BUST_RING", "in_ring"));
    }
    if (planTick !== tick2) {
      const team = friends;
      const tasks = buildTasks(ctx2, obs, state, MY, EN);
      planAssign = runAuction(team, tasks, enemiesAll, MY, tick2, state);
      planTick = tick2;
    }
    const myTask = planAssign.get(me.id);
    if (myTask) {
      const candidates = [];
      if (carrying) {
        const ally = friends.filter((f) => f.id !== me.id).sort((a, b) => dist3(a.x, a.y, MY.x, MY.y) - dist3(b.x, b.y, MY.x, MY.y))[0];
        const target = ally != null ? ally : MY;
        const [dx, dy] = norm(target.x - me.x, target.y - me.y);
        const tx = clamp3(me.x + dx * EJECT_MAX, 0, W2);
        const ty = clamp3(me.y + dy * EJECT_MAX, 0, H2);
        const enemy = enemiesAll[0];
        const deltas = [];
        deltas.push(micro(() => ejectDelta({ me, target: { x: tx, y: ty }, myBase: MY, ally })));
        if (enemy) {
          deltas.push(
            micro(
              () => twoTurnEjectDelta({
                me,
                enemy,
                target: { x: tx, y: ty },
                myBase: MY,
                stunRange: TUNE2.STUN_RANGE,
                canStunEnemy: enemy.state !== 2
              })
            )
          );
        }
        candidates.push({
          act: { type: "EJECT", x: tx, y: ty },
          base: 95,
          deltas,
          tag: "EJECT",
          reason: ally ? "handoff" : "base"
        });
      }
      if (myTask.type === "CARRY") {
        const dHome = dist3(me.x, me.y, MY.x, MY.y);
        if (dHome <= TUNE2.RELEASE_DIST) {
          candidates.push({ act: { type: "RELEASE" }, base: 120, deltas: [], tag: "RELEASE", reason: "carry" });
        }
        const center = myTask.target;
        const radius = 400;
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI * 2 * i / 6;
          const px = clamp3(center.x + Math.cos(ang) * radius, 0, W2);
          const py = clamp3(center.y + Math.sin(ang) * radius, 0, H2);
          const P = spacedTarget(me, { x: px, y: py }, friends);
          const sim = { id: me.id, x: P.x, y: P.y };
          const close = enemiesAll.filter((e) => dist3(e.x, e.y, P.x, P.y) <= 2500);
          const deltas = [];
          for (const e of close) {
            if (microOverBudget()) break;
            deltas.push(
              micro(
                () => twoTurnContestDelta({
                  me: sim,
                  enemy: e,
                  bustMin: BUST_MIN,
                  bustMax: BUST_MAX,
                  stunRange: TUNE2.STUN_RANGE,
                  canStunMe: canStun,
                  canStunEnemy: e.state !== 2
                })
              )
            );
          }
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas, tag: "MOVE_CARRY", reason: `a${i}` });
        }
        const enemy = enemiesAll.find((e) => {
          var _a2;
          return ((_a2 = e.range) != null ? _a2 : dist3(me.x, me.y, e.x, e.y)) <= TUNE2.STUN_RANGE;
        });
        if (enemy && canStun) {
          const delta = micro(
            () => duelStunDelta({
              me,
              enemy,
              canStunMe: true,
              canStunEnemy: enemy.state !== 2,
              stunRange: TUNE2.STUN_RANGE
            })
          );
          candidates.push({ act: { type: "STUN", busterId: enemy.id }, base: 110, deltas: [delta], tag: "STUN", reason: "carry" });
        }
      }
      if (myTask.type === "BUST" && ghosts.length) {
        const g = (_i = ghosts.find((gg) => {
          var _a2;
          return gg.id === ((_a2 = myTask.payload) == null ? void 0 : _a2.ghostId);
        })) != null ? _i : ghosts[0];
        const r = dist3(me.x, me.y, g.x, g.y);
        if (r >= BUST_MIN && r <= BUST_MAX) {
          candidates.push({
            act: { type: "BUST", ghostId: g.id },
            base: 100,
            deltas: (() => {
              const base = micro(
                () => contestedBustDelta({
                  me,
                  ghost: { x: g.x, y: g.y, id: g.id },
                  enemies: enemiesAll,
                  bustMin: BUST_MIN,
                  bustMax: BUST_MAX,
                  stunRange: TUNE2.STUN_RANGE,
                  canStunMe: canStun
                })
              );
              const close = enemiesAll.filter((e) => dist3(e.x, e.y, g.x, g.y) <= 2500);
              let extra = 0;
              for (const e of close) {
                if (microOverBudget()) break;
                extra += micro(
                  () => twoTurnContestDelta({
                    me,
                    enemy: e,
                    ghost: { x: g.x, y: g.y, id: g.id },
                    bustMin: BUST_MIN,
                    bustMax: BUST_MAX,
                    stunRange: TUNE2.STUN_RANGE,
                    canStunMe: canStun,
                    canStunEnemy: e.state !== 2
                  })
                );
              }
              return [base + extra];
            })(),
            tag: "BUST_RING",
            reason: "task_bust"
          });
        }
        const ringR = (BUST_MIN + BUST_MAX) / 2;
        for (let i = 0; i < 8; i++) {
          const ang = Math.PI * 2 * i / 8;
          const px = clamp3(g.x + Math.cos(ang) * ringR, 0, W2);
          const py = clamp3(g.y + Math.sin(ang) * ringR, 0, H2);
          const P = spacedTarget(me, { x: px, y: py }, friends);
          const sim = { id: me.id, x: P.x, y: P.y };
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          const baseDelta = micro(
            () => contestedBustDelta({
              me: sim,
              ghost: { x: g.x, y: g.y, id: g.id },
              enemies: enemiesAll,
              bustMin: BUST_MIN,
              bustMax: BUST_MAX,
              stunRange: TUNE2.STUN_RANGE,
              canStunMe: canStun
            })
          );
          const close = enemiesAll.filter((e) => dist3(e.x, e.y, g.x, g.y) <= 2500);
          let extra = 0;
          for (const e of close) {
            if (microOverBudget()) break;
            extra += micro(
              () => twoTurnContestDelta({
                me: sim,
                enemy: e,
                ghost: { x: g.x, y: g.y, id: g.id },
                bustMin: BUST_MIN,
                bustMax: BUST_MAX,
                stunRange: TUNE2.STUN_RANGE,
                canStunMe: canStun,
                canStunEnemy: e.state !== 2
              })
            );
          }
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas: [baseDelta + extra], tag: "MOVE_RING", reason: `a${i}` });
        }
      }
      if (myTask.type === "INTERCEPT") {
        const enemy = enemiesAll.find((e) => {
          var _a2;
          return e.id === ((_a2 = myTask.payload) == null ? void 0 : _a2.enemyId);
        });
        const center = enemy ? estimateInterceptPoint(me, enemy, MY) : myTask.target;
        const radius = 400;
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI * 2 * i / 6;
          const px = clamp3(center.x + Math.cos(ang) * radius, 0, W2);
          const py = clamp3(center.y + Math.sin(ang) * radius, 0, H2);
          const P = spacedTarget(me, { x: px, y: py }, friends);
          const sim = { id: me.id, x: P.x, y: P.y };
          const deltas = [];
          if (enemy) {
            deltas.push(micro(() => interceptDelta({ me: sim, enemy, myBase: MY })));
            deltas.push(
              micro(() => releaseBlockDelta({ blocker: sim, carrier: enemy, myBase: MY, stunRange: TUNE2.STUN_RANGE }))
            );
            const near = ((_j = enemy.range) != null ? _j : dist3(me.x, me.y, enemy.x, enemy.y)) <= 2500;
            const threat = enemy.state === 1 && dist3(enemy.x, enemy.y, MY.x, MY.y) <= TUNE2.RELEASE_DIST + 2e3;
            if (near || threat) {
              deltas.push(
                micro(
                  () => twoTurnInterceptDelta({
                    me: sim,
                    enemy,
                    myBase: MY,
                    stunRange: TUNE2.STUN_RANGE,
                    canStunMe: canStun,
                    canStunEnemy: enemy.state !== 2
                  })
                )
              );
            }
          }
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas, tag: "MOVE_INT", reason: `a${i}` });
        }
        if (enemy && ((_k = enemy.range) != null ? _k : dist3(me.x, me.y, enemy.x, enemy.y)) <= TUNE2.STUN_RANGE && canStun) {
          let delta = micro(
            () => duelStunDelta({
              me,
              enemy,
              canStunMe: true,
              canStunEnemy: enemy.state !== 2,
              stunRange: TUNE2.STUN_RANGE
            })
          );
          delta += micro(
            () => twoTurnInterceptDelta({
              me,
              enemy,
              myBase: MY,
              stunRange: TUNE2.STUN_RANGE,
              canStunMe: true,
              canStunEnemy: enemy.state !== 2
            })
          );
          candidates.push({ act: { type: "STUN", busterId: enemy.id }, base: 110, deltas: [delta], tag: "STUN", reason: "intercept" });
        }
      }
      if (myTask.type === "SUPPORT") {
        const center = myTask.target;
        const radius = 400;
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI * 2 * i / 6;
          const px = clamp3(center.x + Math.cos(ang) * radius, 0, W2);
          const py = clamp3(center.y + Math.sin(ang) * radius, 0, H2);
          const P = spacedTarget(me, { x: px, y: py }, friends);
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas: [], tag: "MOVE_SUP", reason: `a${i}` });
        }
        const enemy = ((_l = myTask.payload) == null ? void 0 : _l.enemyId) ? enemiesAll.find((e) => e.id === myTask.payload.enemyId) : void 0;
        if (enemy && ((_m = enemy.range) != null ? _m : dist3(me.x, me.y, enemy.x, enemy.y)) <= TUNE2.STUN_RANGE && canStun) {
          const delta = micro(
            () => duelStunDelta({
              me,
              enemy,
              canStunMe: true,
              canStunEnemy: enemy.state !== 2,
              stunRange: TUNE2.STUN_RANGE
            })
          );
          candidates.push({ act: { type: "STUN", busterId: enemy.id }, base: 110, deltas: [delta], tag: "STUN", reason: "support" });
        }
        const ghost = ((_n = myTask.payload) == null ? void 0 : _n.ghostId) ? ghosts.find((g) => g.id === myTask.payload.ghostId) : void 0;
        if (ghost) {
          const r = dist3(me.x, me.y, ghost.x, ghost.y);
          if (r >= BUST_MIN && r <= BUST_MAX) {
            candidates.push({
              act: { type: "BUST", ghostId: ghost.id },
              base: 100,
              deltas: [
                micro(
                  () => contestedBustDelta({
                    me,
                    ghost: { x: ghost.x, y: ghost.y, id: ghost.id },
                    enemies: enemiesAll,
                    bustMin: BUST_MIN,
                    bustMax: BUST_MAX,
                    stunRange: TUNE2.STUN_RANGE,
                    canStunMe: canStun
                  })
                )
              ],
              tag: "BUST_RING",
              reason: "support_bust"
            });
          }
        }
      }
      if (myTask.type === "DEFEND" || myTask.type === "BLOCK" || myTask.type === "EXPLORE") {
        const center = myTask.target;
        const radius = 400;
        for (let i = 0; i < 6; i++) {
          const ang = Math.PI * 2 * i / 6;
          const px = clamp3(center.x + Math.cos(ang) * radius, 0, W2);
          const py = clamp3(center.y + Math.sin(ang) * radius, 0, H2);
          const P = spacedTarget(me, { x: px, y: py }, friends);
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas: [], tag: `MOVE_${myTask.type}`, reason: `a${i}` });
        }
        if (myTask.type === "BLOCK") {
          const carrier = enemiesAll.find((e) => e.state === 1);
          if (carrier) {
            let delta = micro(() => releaseBlockDelta({ blocker: me, carrier, myBase: MY, stunRange: TUNE2.STUN_RANGE }));
            if (dist3(carrier.x, carrier.y, MY.x, MY.y) <= TUNE2.RELEASE_DIST + 2e3) {
              delta += micro(
                () => twoTurnContestDelta({
                  me,
                  enemy: carrier,
                  bustMin: BUST_MIN,
                  bustMax: BUST_MAX,
                  stunRange: TUNE2.STUN_RANGE,
                  canStunMe: canStun,
                  canStunEnemy: carrier.state !== 2
                })
              );
            }
            candidates.push({ act: { type: "MOVE", x: center.x, y: center.y }, base: 100, deltas: [delta], tag: "BLOCK_CORE" });
          }
        }
        if (myTask.type === "DEFEND") {
          const near = enemies.filter((e) => dist3(e.x, e.y, MY.x, MY.y) <= TUNE2.DEFEND_RADIUS).length * 0.2;
          candidates.push({ act: { type: "MOVE", x: center.x, y: center.y }, base: 100, deltas: [near], tag: "DEFEND_CORE" });
        }
        if (myTask.type === "EXPLORE" && ((_o = myTask.payload) == null ? void 0 : _o.wp) !== void 0) {
          const mateId = (_q = (_p = myTask.payload) == null ? void 0 : _p.id) != null ? _q : me.id;
          const Mx = MPatrol(mateId);
          const path = PATROLS[((_r = me.localIndex) != null ? _r : 0) % PATROLS.length];
          const cur = path[Mx.wp % path.length];
          if (dist3(me.x, me.y, cur.x, cur.y) < 800) Mx.wp = (Mx.wp + 1) % path.length;
          const next = path[Mx.wp % path.length];
          const P = spacedTarget(me, next, friends);
          const base = 100 - dist3(me.x, me.y, P.x, P.y) * 0.01;
          candidates.push({ act: { type: "MOVE", x: P.x, y: P.y }, base, deltas: [], tag: "EXPLORE_WP", reason: `wp_${Mx.wp}` });
        }
      }
      if (candidates.length) {
        const scored = candidates.map((c) => ({ s: scoreCandidate({ base: c.base, deltas: c.deltas }), c }));
        scored.sort((a, b) => b.s - a.s);
        const best = scored[0].c;
        return finish(dbg(best.act, best.tag, best.reason));
      }
    }
    if (ghosts.length) {
      const g = ghosts[0];
      const chase = spacedTarget(me, { x: g.x, y: g.y }, friends);
      return finish(dbg({ type: "MOVE", x: chase.x, y: chase.y }, "CHASE", "nearest_ghost"));
    }
    const back = spacedTarget(me, MY, friends);
    return finish(dbg({ type: "MOVE", x: back.x, y: back.y }, "IDLE_BACK", "no_task"));
  }

  // cg-adapter.ts
  var W3 = 16e3;
  var H3 = 9e3;
  var tick = 0;
  var radarUsed = /* @__PURE__ */ new Set();
  var bustersPerPlayer = parseInt(readline(), 10);
  var ghostCount = parseInt(readline(), 10);
  var myTeamId = parseInt(readline(), 10);
  var myBase = myTeamId === 0 ? { x: 0, y: 0 } : { x: W3, y: H3 };
  var enemyBase = myTeamId === 0 ? { x: W3, y: H3 } : { x: 0, y: 0 };
  var ctx = { myBase, enemyBase, bounds: { w: W3, h: H3 } };
  function d(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
  }
  while (true) {
    const n = Number(readline());
    if (Number.isNaN(n)) break;
    const my = [];
    const opp = [];
    const ghosts = [];
    for (let i = 0; i < n; i++) {
      const [idS, xS, yS, tS, sS, vS] = readline().split(" ");
      const id = +idS, x = +xS, y = +yS, type = +tS, state = +sS, value = +vS;
      if (type === myTeamId) my.push({ id, x, y, state, value });
      else if (type === 1 - myTeamId) opp.push({ id, x, y, state, value });
      else ghosts.push({ id, x, y, stamina: state, value });
    }
    my.sort((a, b) => a.id - b.id);
    const lines = [];
    for (const me of my) {
      const self = {
        id: me.id,
        x: me.x,
        y: me.y,
        stunCd: me.value,
        // CG uses `value` for stun cooldown / stun time; good enough for gating STUN
        radarUsed: radarUsed.has(me.id),
        // we maintain locally
        carrying: me.state === 1 ? {} : void 0
      };
      const enemies = opp.map((e) => ({
        id: e.id,
        x: e.x,
        y: e.y,
        carrying: e.state === 1 ? {} : void 0,
        range: d(self, e)
      }));
      const ghostsVisible = ghosts.map((g) => ({
        id: g.id,
        x: g.x,
        y: g.y,
        stamina: g.stamina,
        range: d(self, g)
      }));
      const obs = { self, enemies, ghostsVisible, tick };
      const a = act(ctx, obs) || { type: "MOVE", x: myBase.x, y: myBase.y };
      switch (a.type) {
        case "MOVE": {
          const x = Math.max(0, Math.min(W3, Math.round(a.x)));
          const y = Math.max(0, Math.min(H3, Math.round(a.y)));
          lines.push(`MOVE ${x} ${y}`);
          break;
        }
        case "BUST":
          lines.push(`BUST ${a.ghostId}`);
          break;
        case "RELEASE":
          lines.push(`RELEASE`);
          break;
        case "STUN":
          lines.push(`STUN ${a.busterId}`);
          break;
        case "RADAR":
          radarUsed.add(me.id);
          lines.push(`RADAR`);
          break;
        case "EJECT":
          if (typeof a.x === "number" && typeof a.y === "number") {
            lines.push(`EJECT ${Math.round(a.x)} ${Math.round(a.y)}`);
          } else {
            lines.push(`MOVE ${myBase.x} ${myBase.y}`);
          }
          break;
        default:
          lines.push(`MOVE ${myBase.x} ${myBase.y}`);
          break;
      }
    }
    for (let i = 0; i < bustersPerPlayer; i++) print(lines[i] || `MOVE ${myBase.x} ${myBase.y}`);
    tick++;
  }
